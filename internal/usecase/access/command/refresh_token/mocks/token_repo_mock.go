package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/olgoncharov/otbook/internal/usecase/access/command/refresh_token.tokenRepo -o ./internal/usecase/access/command/refresh_token/mocks/token_repo_mock.go -n TokenRepoMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	repoDTO "github.com/olgoncharov/otbook/internal/repository/dto"
)

// TokenRepoMock implements refreshtoken.tokenRepo
type TokenRepoMock struct {
	t minimock.Tester

	funcDeleteRefreshTokenForUser          func(ctx context.Context, username string) (err error)
	inspectFuncDeleteRefreshTokenForUser   func(ctx context.Context, username string)
	afterDeleteRefreshTokenForUserCounter  uint64
	beforeDeleteRefreshTokenForUserCounter uint64
	DeleteRefreshTokenForUserMock          mTokenRepoMockDeleteRefreshTokenForUser

	funcGetRefreshTokenForUser          func(ctx context.Context, username string) (rp1 *repoDTO.RefreshToken, err error)
	inspectFuncGetRefreshTokenForUser   func(ctx context.Context, username string)
	afterGetRefreshTokenForUserCounter  uint64
	beforeGetRefreshTokenForUserCounter uint64
	GetRefreshTokenForUserMock          mTokenRepoMockGetRefreshTokenForUser

	funcReplaceRefreshToken          func(ctx context.Context, username string, newToken repoDTO.RefreshToken) (err error)
	inspectFuncReplaceRefreshToken   func(ctx context.Context, username string, newToken repoDTO.RefreshToken)
	afterReplaceRefreshTokenCounter  uint64
	beforeReplaceRefreshTokenCounter uint64
	ReplaceRefreshTokenMock          mTokenRepoMockReplaceRefreshToken
}

// NewTokenRepoMock returns a mock for refreshtoken.tokenRepo
func NewTokenRepoMock(t minimock.Tester) *TokenRepoMock {
	m := &TokenRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteRefreshTokenForUserMock = mTokenRepoMockDeleteRefreshTokenForUser{mock: m}
	m.DeleteRefreshTokenForUserMock.callArgs = []*TokenRepoMockDeleteRefreshTokenForUserParams{}

	m.GetRefreshTokenForUserMock = mTokenRepoMockGetRefreshTokenForUser{mock: m}
	m.GetRefreshTokenForUserMock.callArgs = []*TokenRepoMockGetRefreshTokenForUserParams{}

	m.ReplaceRefreshTokenMock = mTokenRepoMockReplaceRefreshToken{mock: m}
	m.ReplaceRefreshTokenMock.callArgs = []*TokenRepoMockReplaceRefreshTokenParams{}

	return m
}

type mTokenRepoMockDeleteRefreshTokenForUser struct {
	mock               *TokenRepoMock
	defaultExpectation *TokenRepoMockDeleteRefreshTokenForUserExpectation
	expectations       []*TokenRepoMockDeleteRefreshTokenForUserExpectation

	callArgs []*TokenRepoMockDeleteRefreshTokenForUserParams
	mutex    sync.RWMutex
}

// TokenRepoMockDeleteRefreshTokenForUserExpectation specifies expectation struct of the tokenRepo.DeleteRefreshTokenForUser
type TokenRepoMockDeleteRefreshTokenForUserExpectation struct {
	mock    *TokenRepoMock
	params  *TokenRepoMockDeleteRefreshTokenForUserParams
	results *TokenRepoMockDeleteRefreshTokenForUserResults
	Counter uint64
}

// TokenRepoMockDeleteRefreshTokenForUserParams contains parameters of the tokenRepo.DeleteRefreshTokenForUser
type TokenRepoMockDeleteRefreshTokenForUserParams struct {
	ctx      context.Context
	username string
}

// TokenRepoMockDeleteRefreshTokenForUserResults contains results of the tokenRepo.DeleteRefreshTokenForUser
type TokenRepoMockDeleteRefreshTokenForUserResults struct {
	err error
}

// Expect sets up expected params for tokenRepo.DeleteRefreshTokenForUser
func (mmDeleteRefreshTokenForUser *mTokenRepoMockDeleteRefreshTokenForUser) Expect(ctx context.Context, username string) *mTokenRepoMockDeleteRefreshTokenForUser {
	if mmDeleteRefreshTokenForUser.mock.funcDeleteRefreshTokenForUser != nil {
		mmDeleteRefreshTokenForUser.mock.t.Fatalf("TokenRepoMock.DeleteRefreshTokenForUser mock is already set by Set")
	}

	if mmDeleteRefreshTokenForUser.defaultExpectation == nil {
		mmDeleteRefreshTokenForUser.defaultExpectation = &TokenRepoMockDeleteRefreshTokenForUserExpectation{}
	}

	mmDeleteRefreshTokenForUser.defaultExpectation.params = &TokenRepoMockDeleteRefreshTokenForUserParams{ctx, username}
	for _, e := range mmDeleteRefreshTokenForUser.expectations {
		if minimock.Equal(e.params, mmDeleteRefreshTokenForUser.defaultExpectation.params) {
			mmDeleteRefreshTokenForUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteRefreshTokenForUser.defaultExpectation.params)
		}
	}

	return mmDeleteRefreshTokenForUser
}

// Inspect accepts an inspector function that has same arguments as the tokenRepo.DeleteRefreshTokenForUser
func (mmDeleteRefreshTokenForUser *mTokenRepoMockDeleteRefreshTokenForUser) Inspect(f func(ctx context.Context, username string)) *mTokenRepoMockDeleteRefreshTokenForUser {
	if mmDeleteRefreshTokenForUser.mock.inspectFuncDeleteRefreshTokenForUser != nil {
		mmDeleteRefreshTokenForUser.mock.t.Fatalf("Inspect function is already set for TokenRepoMock.DeleteRefreshTokenForUser")
	}

	mmDeleteRefreshTokenForUser.mock.inspectFuncDeleteRefreshTokenForUser = f

	return mmDeleteRefreshTokenForUser
}

// Return sets up results that will be returned by tokenRepo.DeleteRefreshTokenForUser
func (mmDeleteRefreshTokenForUser *mTokenRepoMockDeleteRefreshTokenForUser) Return(err error) *TokenRepoMock {
	if mmDeleteRefreshTokenForUser.mock.funcDeleteRefreshTokenForUser != nil {
		mmDeleteRefreshTokenForUser.mock.t.Fatalf("TokenRepoMock.DeleteRefreshTokenForUser mock is already set by Set")
	}

	if mmDeleteRefreshTokenForUser.defaultExpectation == nil {
		mmDeleteRefreshTokenForUser.defaultExpectation = &TokenRepoMockDeleteRefreshTokenForUserExpectation{mock: mmDeleteRefreshTokenForUser.mock}
	}
	mmDeleteRefreshTokenForUser.defaultExpectation.results = &TokenRepoMockDeleteRefreshTokenForUserResults{err}
	return mmDeleteRefreshTokenForUser.mock
}

//Set uses given function f to mock the tokenRepo.DeleteRefreshTokenForUser method
func (mmDeleteRefreshTokenForUser *mTokenRepoMockDeleteRefreshTokenForUser) Set(f func(ctx context.Context, username string) (err error)) *TokenRepoMock {
	if mmDeleteRefreshTokenForUser.defaultExpectation != nil {
		mmDeleteRefreshTokenForUser.mock.t.Fatalf("Default expectation is already set for the tokenRepo.DeleteRefreshTokenForUser method")
	}

	if len(mmDeleteRefreshTokenForUser.expectations) > 0 {
		mmDeleteRefreshTokenForUser.mock.t.Fatalf("Some expectations are already set for the tokenRepo.DeleteRefreshTokenForUser method")
	}

	mmDeleteRefreshTokenForUser.mock.funcDeleteRefreshTokenForUser = f
	return mmDeleteRefreshTokenForUser.mock
}

// When sets expectation for the tokenRepo.DeleteRefreshTokenForUser which will trigger the result defined by the following
// Then helper
func (mmDeleteRefreshTokenForUser *mTokenRepoMockDeleteRefreshTokenForUser) When(ctx context.Context, username string) *TokenRepoMockDeleteRefreshTokenForUserExpectation {
	if mmDeleteRefreshTokenForUser.mock.funcDeleteRefreshTokenForUser != nil {
		mmDeleteRefreshTokenForUser.mock.t.Fatalf("TokenRepoMock.DeleteRefreshTokenForUser mock is already set by Set")
	}

	expectation := &TokenRepoMockDeleteRefreshTokenForUserExpectation{
		mock:   mmDeleteRefreshTokenForUser.mock,
		params: &TokenRepoMockDeleteRefreshTokenForUserParams{ctx, username},
	}
	mmDeleteRefreshTokenForUser.expectations = append(mmDeleteRefreshTokenForUser.expectations, expectation)
	return expectation
}

// Then sets up tokenRepo.DeleteRefreshTokenForUser return parameters for the expectation previously defined by the When method
func (e *TokenRepoMockDeleteRefreshTokenForUserExpectation) Then(err error) *TokenRepoMock {
	e.results = &TokenRepoMockDeleteRefreshTokenForUserResults{err}
	return e.mock
}

// DeleteRefreshTokenForUser implements refreshtoken.tokenRepo
func (mmDeleteRefreshTokenForUser *TokenRepoMock) DeleteRefreshTokenForUser(ctx context.Context, username string) (err error) {
	mm_atomic.AddUint64(&mmDeleteRefreshTokenForUser.beforeDeleteRefreshTokenForUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteRefreshTokenForUser.afterDeleteRefreshTokenForUserCounter, 1)

	if mmDeleteRefreshTokenForUser.inspectFuncDeleteRefreshTokenForUser != nil {
		mmDeleteRefreshTokenForUser.inspectFuncDeleteRefreshTokenForUser(ctx, username)
	}

	mm_params := &TokenRepoMockDeleteRefreshTokenForUserParams{ctx, username}

	// Record call args
	mmDeleteRefreshTokenForUser.DeleteRefreshTokenForUserMock.mutex.Lock()
	mmDeleteRefreshTokenForUser.DeleteRefreshTokenForUserMock.callArgs = append(mmDeleteRefreshTokenForUser.DeleteRefreshTokenForUserMock.callArgs, mm_params)
	mmDeleteRefreshTokenForUser.DeleteRefreshTokenForUserMock.mutex.Unlock()

	for _, e := range mmDeleteRefreshTokenForUser.DeleteRefreshTokenForUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteRefreshTokenForUser.DeleteRefreshTokenForUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteRefreshTokenForUser.DeleteRefreshTokenForUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteRefreshTokenForUser.DeleteRefreshTokenForUserMock.defaultExpectation.params
		mm_got := TokenRepoMockDeleteRefreshTokenForUserParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteRefreshTokenForUser.t.Errorf("TokenRepoMock.DeleteRefreshTokenForUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteRefreshTokenForUser.DeleteRefreshTokenForUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteRefreshTokenForUser.t.Fatal("No results are set for the TokenRepoMock.DeleteRefreshTokenForUser")
		}
		return (*mm_results).err
	}
	if mmDeleteRefreshTokenForUser.funcDeleteRefreshTokenForUser != nil {
		return mmDeleteRefreshTokenForUser.funcDeleteRefreshTokenForUser(ctx, username)
	}
	mmDeleteRefreshTokenForUser.t.Fatalf("Unexpected call to TokenRepoMock.DeleteRefreshTokenForUser. %v %v", ctx, username)
	return
}

// DeleteRefreshTokenForUserAfterCounter returns a count of finished TokenRepoMock.DeleteRefreshTokenForUser invocations
func (mmDeleteRefreshTokenForUser *TokenRepoMock) DeleteRefreshTokenForUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRefreshTokenForUser.afterDeleteRefreshTokenForUserCounter)
}

// DeleteRefreshTokenForUserBeforeCounter returns a count of TokenRepoMock.DeleteRefreshTokenForUser invocations
func (mmDeleteRefreshTokenForUser *TokenRepoMock) DeleteRefreshTokenForUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteRefreshTokenForUser.beforeDeleteRefreshTokenForUserCounter)
}

// Calls returns a list of arguments used in each call to TokenRepoMock.DeleteRefreshTokenForUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteRefreshTokenForUser *mTokenRepoMockDeleteRefreshTokenForUser) Calls() []*TokenRepoMockDeleteRefreshTokenForUserParams {
	mmDeleteRefreshTokenForUser.mutex.RLock()

	argCopy := make([]*TokenRepoMockDeleteRefreshTokenForUserParams, len(mmDeleteRefreshTokenForUser.callArgs))
	copy(argCopy, mmDeleteRefreshTokenForUser.callArgs)

	mmDeleteRefreshTokenForUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteRefreshTokenForUserDone returns true if the count of the DeleteRefreshTokenForUser invocations corresponds
// the number of defined expectations
func (m *TokenRepoMock) MinimockDeleteRefreshTokenForUserDone() bool {
	for _, e := range m.DeleteRefreshTokenForUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRefreshTokenForUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteRefreshTokenForUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRefreshTokenForUser != nil && mm_atomic.LoadUint64(&m.afterDeleteRefreshTokenForUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteRefreshTokenForUserInspect logs each unmet expectation
func (m *TokenRepoMock) MinimockDeleteRefreshTokenForUserInspect() {
	for _, e := range m.DeleteRefreshTokenForUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenRepoMock.DeleteRefreshTokenForUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteRefreshTokenForUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteRefreshTokenForUserCounter) < 1 {
		if m.DeleteRefreshTokenForUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TokenRepoMock.DeleteRefreshTokenForUser")
		} else {
			m.t.Errorf("Expected call to TokenRepoMock.DeleteRefreshTokenForUser with params: %#v", *m.DeleteRefreshTokenForUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteRefreshTokenForUser != nil && mm_atomic.LoadUint64(&m.afterDeleteRefreshTokenForUserCounter) < 1 {
		m.t.Error("Expected call to TokenRepoMock.DeleteRefreshTokenForUser")
	}
}

type mTokenRepoMockGetRefreshTokenForUser struct {
	mock               *TokenRepoMock
	defaultExpectation *TokenRepoMockGetRefreshTokenForUserExpectation
	expectations       []*TokenRepoMockGetRefreshTokenForUserExpectation

	callArgs []*TokenRepoMockGetRefreshTokenForUserParams
	mutex    sync.RWMutex
}

// TokenRepoMockGetRefreshTokenForUserExpectation specifies expectation struct of the tokenRepo.GetRefreshTokenForUser
type TokenRepoMockGetRefreshTokenForUserExpectation struct {
	mock    *TokenRepoMock
	params  *TokenRepoMockGetRefreshTokenForUserParams
	results *TokenRepoMockGetRefreshTokenForUserResults
	Counter uint64
}

// TokenRepoMockGetRefreshTokenForUserParams contains parameters of the tokenRepo.GetRefreshTokenForUser
type TokenRepoMockGetRefreshTokenForUserParams struct {
	ctx      context.Context
	username string
}

// TokenRepoMockGetRefreshTokenForUserResults contains results of the tokenRepo.GetRefreshTokenForUser
type TokenRepoMockGetRefreshTokenForUserResults struct {
	rp1 *repoDTO.RefreshToken
	err error
}

// Expect sets up expected params for tokenRepo.GetRefreshTokenForUser
func (mmGetRefreshTokenForUser *mTokenRepoMockGetRefreshTokenForUser) Expect(ctx context.Context, username string) *mTokenRepoMockGetRefreshTokenForUser {
	if mmGetRefreshTokenForUser.mock.funcGetRefreshTokenForUser != nil {
		mmGetRefreshTokenForUser.mock.t.Fatalf("TokenRepoMock.GetRefreshTokenForUser mock is already set by Set")
	}

	if mmGetRefreshTokenForUser.defaultExpectation == nil {
		mmGetRefreshTokenForUser.defaultExpectation = &TokenRepoMockGetRefreshTokenForUserExpectation{}
	}

	mmGetRefreshTokenForUser.defaultExpectation.params = &TokenRepoMockGetRefreshTokenForUserParams{ctx, username}
	for _, e := range mmGetRefreshTokenForUser.expectations {
		if minimock.Equal(e.params, mmGetRefreshTokenForUser.defaultExpectation.params) {
			mmGetRefreshTokenForUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefreshTokenForUser.defaultExpectation.params)
		}
	}

	return mmGetRefreshTokenForUser
}

// Inspect accepts an inspector function that has same arguments as the tokenRepo.GetRefreshTokenForUser
func (mmGetRefreshTokenForUser *mTokenRepoMockGetRefreshTokenForUser) Inspect(f func(ctx context.Context, username string)) *mTokenRepoMockGetRefreshTokenForUser {
	if mmGetRefreshTokenForUser.mock.inspectFuncGetRefreshTokenForUser != nil {
		mmGetRefreshTokenForUser.mock.t.Fatalf("Inspect function is already set for TokenRepoMock.GetRefreshTokenForUser")
	}

	mmGetRefreshTokenForUser.mock.inspectFuncGetRefreshTokenForUser = f

	return mmGetRefreshTokenForUser
}

// Return sets up results that will be returned by tokenRepo.GetRefreshTokenForUser
func (mmGetRefreshTokenForUser *mTokenRepoMockGetRefreshTokenForUser) Return(rp1 *repoDTO.RefreshToken, err error) *TokenRepoMock {
	if mmGetRefreshTokenForUser.mock.funcGetRefreshTokenForUser != nil {
		mmGetRefreshTokenForUser.mock.t.Fatalf("TokenRepoMock.GetRefreshTokenForUser mock is already set by Set")
	}

	if mmGetRefreshTokenForUser.defaultExpectation == nil {
		mmGetRefreshTokenForUser.defaultExpectation = &TokenRepoMockGetRefreshTokenForUserExpectation{mock: mmGetRefreshTokenForUser.mock}
	}
	mmGetRefreshTokenForUser.defaultExpectation.results = &TokenRepoMockGetRefreshTokenForUserResults{rp1, err}
	return mmGetRefreshTokenForUser.mock
}

//Set uses given function f to mock the tokenRepo.GetRefreshTokenForUser method
func (mmGetRefreshTokenForUser *mTokenRepoMockGetRefreshTokenForUser) Set(f func(ctx context.Context, username string) (rp1 *repoDTO.RefreshToken, err error)) *TokenRepoMock {
	if mmGetRefreshTokenForUser.defaultExpectation != nil {
		mmGetRefreshTokenForUser.mock.t.Fatalf("Default expectation is already set for the tokenRepo.GetRefreshTokenForUser method")
	}

	if len(mmGetRefreshTokenForUser.expectations) > 0 {
		mmGetRefreshTokenForUser.mock.t.Fatalf("Some expectations are already set for the tokenRepo.GetRefreshTokenForUser method")
	}

	mmGetRefreshTokenForUser.mock.funcGetRefreshTokenForUser = f
	return mmGetRefreshTokenForUser.mock
}

// When sets expectation for the tokenRepo.GetRefreshTokenForUser which will trigger the result defined by the following
// Then helper
func (mmGetRefreshTokenForUser *mTokenRepoMockGetRefreshTokenForUser) When(ctx context.Context, username string) *TokenRepoMockGetRefreshTokenForUserExpectation {
	if mmGetRefreshTokenForUser.mock.funcGetRefreshTokenForUser != nil {
		mmGetRefreshTokenForUser.mock.t.Fatalf("TokenRepoMock.GetRefreshTokenForUser mock is already set by Set")
	}

	expectation := &TokenRepoMockGetRefreshTokenForUserExpectation{
		mock:   mmGetRefreshTokenForUser.mock,
		params: &TokenRepoMockGetRefreshTokenForUserParams{ctx, username},
	}
	mmGetRefreshTokenForUser.expectations = append(mmGetRefreshTokenForUser.expectations, expectation)
	return expectation
}

// Then sets up tokenRepo.GetRefreshTokenForUser return parameters for the expectation previously defined by the When method
func (e *TokenRepoMockGetRefreshTokenForUserExpectation) Then(rp1 *repoDTO.RefreshToken, err error) *TokenRepoMock {
	e.results = &TokenRepoMockGetRefreshTokenForUserResults{rp1, err}
	return e.mock
}

// GetRefreshTokenForUser implements refreshtoken.tokenRepo
func (mmGetRefreshTokenForUser *TokenRepoMock) GetRefreshTokenForUser(ctx context.Context, username string) (rp1 *repoDTO.RefreshToken, err error) {
	mm_atomic.AddUint64(&mmGetRefreshTokenForUser.beforeGetRefreshTokenForUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefreshTokenForUser.afterGetRefreshTokenForUserCounter, 1)

	if mmGetRefreshTokenForUser.inspectFuncGetRefreshTokenForUser != nil {
		mmGetRefreshTokenForUser.inspectFuncGetRefreshTokenForUser(ctx, username)
	}

	mm_params := &TokenRepoMockGetRefreshTokenForUserParams{ctx, username}

	// Record call args
	mmGetRefreshTokenForUser.GetRefreshTokenForUserMock.mutex.Lock()
	mmGetRefreshTokenForUser.GetRefreshTokenForUserMock.callArgs = append(mmGetRefreshTokenForUser.GetRefreshTokenForUserMock.callArgs, mm_params)
	mmGetRefreshTokenForUser.GetRefreshTokenForUserMock.mutex.Unlock()

	for _, e := range mmGetRefreshTokenForUser.GetRefreshTokenForUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmGetRefreshTokenForUser.GetRefreshTokenForUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefreshTokenForUser.GetRefreshTokenForUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefreshTokenForUser.GetRefreshTokenForUserMock.defaultExpectation.params
		mm_got := TokenRepoMockGetRefreshTokenForUserParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefreshTokenForUser.t.Errorf("TokenRepoMock.GetRefreshTokenForUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefreshTokenForUser.GetRefreshTokenForUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefreshTokenForUser.t.Fatal("No results are set for the TokenRepoMock.GetRefreshTokenForUser")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmGetRefreshTokenForUser.funcGetRefreshTokenForUser != nil {
		return mmGetRefreshTokenForUser.funcGetRefreshTokenForUser(ctx, username)
	}
	mmGetRefreshTokenForUser.t.Fatalf("Unexpected call to TokenRepoMock.GetRefreshTokenForUser. %v %v", ctx, username)
	return
}

// GetRefreshTokenForUserAfterCounter returns a count of finished TokenRepoMock.GetRefreshTokenForUser invocations
func (mmGetRefreshTokenForUser *TokenRepoMock) GetRefreshTokenForUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshTokenForUser.afterGetRefreshTokenForUserCounter)
}

// GetRefreshTokenForUserBeforeCounter returns a count of TokenRepoMock.GetRefreshTokenForUser invocations
func (mmGetRefreshTokenForUser *TokenRepoMock) GetRefreshTokenForUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefreshTokenForUser.beforeGetRefreshTokenForUserCounter)
}

// Calls returns a list of arguments used in each call to TokenRepoMock.GetRefreshTokenForUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefreshTokenForUser *mTokenRepoMockGetRefreshTokenForUser) Calls() []*TokenRepoMockGetRefreshTokenForUserParams {
	mmGetRefreshTokenForUser.mutex.RLock()

	argCopy := make([]*TokenRepoMockGetRefreshTokenForUserParams, len(mmGetRefreshTokenForUser.callArgs))
	copy(argCopy, mmGetRefreshTokenForUser.callArgs)

	mmGetRefreshTokenForUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefreshTokenForUserDone returns true if the count of the GetRefreshTokenForUser invocations corresponds
// the number of defined expectations
func (m *TokenRepoMock) MinimockGetRefreshTokenForUserDone() bool {
	for _, e := range m.GetRefreshTokenForUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefreshTokenForUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRefreshTokenForUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefreshTokenForUser != nil && mm_atomic.LoadUint64(&m.afterGetRefreshTokenForUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRefreshTokenForUserInspect logs each unmet expectation
func (m *TokenRepoMock) MinimockGetRefreshTokenForUserInspect() {
	for _, e := range m.GetRefreshTokenForUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenRepoMock.GetRefreshTokenForUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefreshTokenForUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRefreshTokenForUserCounter) < 1 {
		if m.GetRefreshTokenForUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TokenRepoMock.GetRefreshTokenForUser")
		} else {
			m.t.Errorf("Expected call to TokenRepoMock.GetRefreshTokenForUser with params: %#v", *m.GetRefreshTokenForUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefreshTokenForUser != nil && mm_atomic.LoadUint64(&m.afterGetRefreshTokenForUserCounter) < 1 {
		m.t.Error("Expected call to TokenRepoMock.GetRefreshTokenForUser")
	}
}

type mTokenRepoMockReplaceRefreshToken struct {
	mock               *TokenRepoMock
	defaultExpectation *TokenRepoMockReplaceRefreshTokenExpectation
	expectations       []*TokenRepoMockReplaceRefreshTokenExpectation

	callArgs []*TokenRepoMockReplaceRefreshTokenParams
	mutex    sync.RWMutex
}

// TokenRepoMockReplaceRefreshTokenExpectation specifies expectation struct of the tokenRepo.ReplaceRefreshToken
type TokenRepoMockReplaceRefreshTokenExpectation struct {
	mock    *TokenRepoMock
	params  *TokenRepoMockReplaceRefreshTokenParams
	results *TokenRepoMockReplaceRefreshTokenResults
	Counter uint64
}

// TokenRepoMockReplaceRefreshTokenParams contains parameters of the tokenRepo.ReplaceRefreshToken
type TokenRepoMockReplaceRefreshTokenParams struct {
	ctx      context.Context
	username string
	newToken repoDTO.RefreshToken
}

// TokenRepoMockReplaceRefreshTokenResults contains results of the tokenRepo.ReplaceRefreshToken
type TokenRepoMockReplaceRefreshTokenResults struct {
	err error
}

// Expect sets up expected params for tokenRepo.ReplaceRefreshToken
func (mmReplaceRefreshToken *mTokenRepoMockReplaceRefreshToken) Expect(ctx context.Context, username string, newToken repoDTO.RefreshToken) *mTokenRepoMockReplaceRefreshToken {
	if mmReplaceRefreshToken.mock.funcReplaceRefreshToken != nil {
		mmReplaceRefreshToken.mock.t.Fatalf("TokenRepoMock.ReplaceRefreshToken mock is already set by Set")
	}

	if mmReplaceRefreshToken.defaultExpectation == nil {
		mmReplaceRefreshToken.defaultExpectation = &TokenRepoMockReplaceRefreshTokenExpectation{}
	}

	mmReplaceRefreshToken.defaultExpectation.params = &TokenRepoMockReplaceRefreshTokenParams{ctx, username, newToken}
	for _, e := range mmReplaceRefreshToken.expectations {
		if minimock.Equal(e.params, mmReplaceRefreshToken.defaultExpectation.params) {
			mmReplaceRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReplaceRefreshToken.defaultExpectation.params)
		}
	}

	return mmReplaceRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the tokenRepo.ReplaceRefreshToken
func (mmReplaceRefreshToken *mTokenRepoMockReplaceRefreshToken) Inspect(f func(ctx context.Context, username string, newToken repoDTO.RefreshToken)) *mTokenRepoMockReplaceRefreshToken {
	if mmReplaceRefreshToken.mock.inspectFuncReplaceRefreshToken != nil {
		mmReplaceRefreshToken.mock.t.Fatalf("Inspect function is already set for TokenRepoMock.ReplaceRefreshToken")
	}

	mmReplaceRefreshToken.mock.inspectFuncReplaceRefreshToken = f

	return mmReplaceRefreshToken
}

// Return sets up results that will be returned by tokenRepo.ReplaceRefreshToken
func (mmReplaceRefreshToken *mTokenRepoMockReplaceRefreshToken) Return(err error) *TokenRepoMock {
	if mmReplaceRefreshToken.mock.funcReplaceRefreshToken != nil {
		mmReplaceRefreshToken.mock.t.Fatalf("TokenRepoMock.ReplaceRefreshToken mock is already set by Set")
	}

	if mmReplaceRefreshToken.defaultExpectation == nil {
		mmReplaceRefreshToken.defaultExpectation = &TokenRepoMockReplaceRefreshTokenExpectation{mock: mmReplaceRefreshToken.mock}
	}
	mmReplaceRefreshToken.defaultExpectation.results = &TokenRepoMockReplaceRefreshTokenResults{err}
	return mmReplaceRefreshToken.mock
}

//Set uses given function f to mock the tokenRepo.ReplaceRefreshToken method
func (mmReplaceRefreshToken *mTokenRepoMockReplaceRefreshToken) Set(f func(ctx context.Context, username string, newToken repoDTO.RefreshToken) (err error)) *TokenRepoMock {
	if mmReplaceRefreshToken.defaultExpectation != nil {
		mmReplaceRefreshToken.mock.t.Fatalf("Default expectation is already set for the tokenRepo.ReplaceRefreshToken method")
	}

	if len(mmReplaceRefreshToken.expectations) > 0 {
		mmReplaceRefreshToken.mock.t.Fatalf("Some expectations are already set for the tokenRepo.ReplaceRefreshToken method")
	}

	mmReplaceRefreshToken.mock.funcReplaceRefreshToken = f
	return mmReplaceRefreshToken.mock
}

// When sets expectation for the tokenRepo.ReplaceRefreshToken which will trigger the result defined by the following
// Then helper
func (mmReplaceRefreshToken *mTokenRepoMockReplaceRefreshToken) When(ctx context.Context, username string, newToken repoDTO.RefreshToken) *TokenRepoMockReplaceRefreshTokenExpectation {
	if mmReplaceRefreshToken.mock.funcReplaceRefreshToken != nil {
		mmReplaceRefreshToken.mock.t.Fatalf("TokenRepoMock.ReplaceRefreshToken mock is already set by Set")
	}

	expectation := &TokenRepoMockReplaceRefreshTokenExpectation{
		mock:   mmReplaceRefreshToken.mock,
		params: &TokenRepoMockReplaceRefreshTokenParams{ctx, username, newToken},
	}
	mmReplaceRefreshToken.expectations = append(mmReplaceRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up tokenRepo.ReplaceRefreshToken return parameters for the expectation previously defined by the When method
func (e *TokenRepoMockReplaceRefreshTokenExpectation) Then(err error) *TokenRepoMock {
	e.results = &TokenRepoMockReplaceRefreshTokenResults{err}
	return e.mock
}

// ReplaceRefreshToken implements refreshtoken.tokenRepo
func (mmReplaceRefreshToken *TokenRepoMock) ReplaceRefreshToken(ctx context.Context, username string, newToken repoDTO.RefreshToken) (err error) {
	mm_atomic.AddUint64(&mmReplaceRefreshToken.beforeReplaceRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmReplaceRefreshToken.afterReplaceRefreshTokenCounter, 1)

	if mmReplaceRefreshToken.inspectFuncReplaceRefreshToken != nil {
		mmReplaceRefreshToken.inspectFuncReplaceRefreshToken(ctx, username, newToken)
	}

	mm_params := &TokenRepoMockReplaceRefreshTokenParams{ctx, username, newToken}

	// Record call args
	mmReplaceRefreshToken.ReplaceRefreshTokenMock.mutex.Lock()
	mmReplaceRefreshToken.ReplaceRefreshTokenMock.callArgs = append(mmReplaceRefreshToken.ReplaceRefreshTokenMock.callArgs, mm_params)
	mmReplaceRefreshToken.ReplaceRefreshTokenMock.mutex.Unlock()

	for _, e := range mmReplaceRefreshToken.ReplaceRefreshTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReplaceRefreshToken.ReplaceRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReplaceRefreshToken.ReplaceRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmReplaceRefreshToken.ReplaceRefreshTokenMock.defaultExpectation.params
		mm_got := TokenRepoMockReplaceRefreshTokenParams{ctx, username, newToken}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReplaceRefreshToken.t.Errorf("TokenRepoMock.ReplaceRefreshToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReplaceRefreshToken.ReplaceRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmReplaceRefreshToken.t.Fatal("No results are set for the TokenRepoMock.ReplaceRefreshToken")
		}
		return (*mm_results).err
	}
	if mmReplaceRefreshToken.funcReplaceRefreshToken != nil {
		return mmReplaceRefreshToken.funcReplaceRefreshToken(ctx, username, newToken)
	}
	mmReplaceRefreshToken.t.Fatalf("Unexpected call to TokenRepoMock.ReplaceRefreshToken. %v %v %v", ctx, username, newToken)
	return
}

// ReplaceRefreshTokenAfterCounter returns a count of finished TokenRepoMock.ReplaceRefreshToken invocations
func (mmReplaceRefreshToken *TokenRepoMock) ReplaceRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReplaceRefreshToken.afterReplaceRefreshTokenCounter)
}

// ReplaceRefreshTokenBeforeCounter returns a count of TokenRepoMock.ReplaceRefreshToken invocations
func (mmReplaceRefreshToken *TokenRepoMock) ReplaceRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReplaceRefreshToken.beforeReplaceRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to TokenRepoMock.ReplaceRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReplaceRefreshToken *mTokenRepoMockReplaceRefreshToken) Calls() []*TokenRepoMockReplaceRefreshTokenParams {
	mmReplaceRefreshToken.mutex.RLock()

	argCopy := make([]*TokenRepoMockReplaceRefreshTokenParams, len(mmReplaceRefreshToken.callArgs))
	copy(argCopy, mmReplaceRefreshToken.callArgs)

	mmReplaceRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockReplaceRefreshTokenDone returns true if the count of the ReplaceRefreshToken invocations corresponds
// the number of defined expectations
func (m *TokenRepoMock) MinimockReplaceRefreshTokenDone() bool {
	for _, e := range m.ReplaceRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReplaceRefreshTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReplaceRefreshTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReplaceRefreshToken != nil && mm_atomic.LoadUint64(&m.afterReplaceRefreshTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockReplaceRefreshTokenInspect logs each unmet expectation
func (m *TokenRepoMock) MinimockReplaceRefreshTokenInspect() {
	for _, e := range m.ReplaceRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TokenRepoMock.ReplaceRefreshToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReplaceRefreshTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReplaceRefreshTokenCounter) < 1 {
		if m.ReplaceRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TokenRepoMock.ReplaceRefreshToken")
		} else {
			m.t.Errorf("Expected call to TokenRepoMock.ReplaceRefreshToken with params: %#v", *m.ReplaceRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReplaceRefreshToken != nil && mm_atomic.LoadUint64(&m.afterReplaceRefreshTokenCounter) < 1 {
		m.t.Error("Expected call to TokenRepoMock.ReplaceRefreshToken")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TokenRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockDeleteRefreshTokenForUserInspect()

		m.MinimockGetRefreshTokenForUserInspect()

		m.MinimockReplaceRefreshTokenInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TokenRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TokenRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteRefreshTokenForUserDone() &&
		m.MinimockGetRefreshTokenForUserDone() &&
		m.MinimockReplaceRefreshTokenDone()
}
