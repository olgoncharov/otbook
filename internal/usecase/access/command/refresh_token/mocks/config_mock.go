package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/olgoncharov/otbook/internal/usecase/access/command/refresh_token.config -o ./internal/usecase/access/command/refresh_token/mocks/config_mock.go -n ConfigMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ConfigMock implements refreshtoken.config
type ConfigMock struct {
	t minimock.Tester

	funcJWTRefreshTokenTTL          func() (u1 uint64)
	inspectFuncJWTRefreshTokenTTL   func()
	afterJWTRefreshTokenTTLCounter  uint64
	beforeJWTRefreshTokenTTLCounter uint64
	JWTRefreshTokenTTLMock          mConfigMockJWTRefreshTokenTTL
}

// NewConfigMock returns a mock for refreshtoken.config
func NewConfigMock(t minimock.Tester) *ConfigMock {
	m := &ConfigMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.JWTRefreshTokenTTLMock = mConfigMockJWTRefreshTokenTTL{mock: m}

	return m
}

type mConfigMockJWTRefreshTokenTTL struct {
	mock               *ConfigMock
	defaultExpectation *ConfigMockJWTRefreshTokenTTLExpectation
	expectations       []*ConfigMockJWTRefreshTokenTTLExpectation
}

// ConfigMockJWTRefreshTokenTTLExpectation specifies expectation struct of the config.JWTRefreshTokenTTL
type ConfigMockJWTRefreshTokenTTLExpectation struct {
	mock *ConfigMock

	results *ConfigMockJWTRefreshTokenTTLResults
	Counter uint64
}

// ConfigMockJWTRefreshTokenTTLResults contains results of the config.JWTRefreshTokenTTL
type ConfigMockJWTRefreshTokenTTLResults struct {
	u1 uint64
}

// Expect sets up expected params for config.JWTRefreshTokenTTL
func (mmJWTRefreshTokenTTL *mConfigMockJWTRefreshTokenTTL) Expect() *mConfigMockJWTRefreshTokenTTL {
	if mmJWTRefreshTokenTTL.mock.funcJWTRefreshTokenTTL != nil {
		mmJWTRefreshTokenTTL.mock.t.Fatalf("ConfigMock.JWTRefreshTokenTTL mock is already set by Set")
	}

	if mmJWTRefreshTokenTTL.defaultExpectation == nil {
		mmJWTRefreshTokenTTL.defaultExpectation = &ConfigMockJWTRefreshTokenTTLExpectation{}
	}

	return mmJWTRefreshTokenTTL
}

// Inspect accepts an inspector function that has same arguments as the config.JWTRefreshTokenTTL
func (mmJWTRefreshTokenTTL *mConfigMockJWTRefreshTokenTTL) Inspect(f func()) *mConfigMockJWTRefreshTokenTTL {
	if mmJWTRefreshTokenTTL.mock.inspectFuncJWTRefreshTokenTTL != nil {
		mmJWTRefreshTokenTTL.mock.t.Fatalf("Inspect function is already set for ConfigMock.JWTRefreshTokenTTL")
	}

	mmJWTRefreshTokenTTL.mock.inspectFuncJWTRefreshTokenTTL = f

	return mmJWTRefreshTokenTTL
}

// Return sets up results that will be returned by config.JWTRefreshTokenTTL
func (mmJWTRefreshTokenTTL *mConfigMockJWTRefreshTokenTTL) Return(u1 uint64) *ConfigMock {
	if mmJWTRefreshTokenTTL.mock.funcJWTRefreshTokenTTL != nil {
		mmJWTRefreshTokenTTL.mock.t.Fatalf("ConfigMock.JWTRefreshTokenTTL mock is already set by Set")
	}

	if mmJWTRefreshTokenTTL.defaultExpectation == nil {
		mmJWTRefreshTokenTTL.defaultExpectation = &ConfigMockJWTRefreshTokenTTLExpectation{mock: mmJWTRefreshTokenTTL.mock}
	}
	mmJWTRefreshTokenTTL.defaultExpectation.results = &ConfigMockJWTRefreshTokenTTLResults{u1}
	return mmJWTRefreshTokenTTL.mock
}

//Set uses given function f to mock the config.JWTRefreshTokenTTL method
func (mmJWTRefreshTokenTTL *mConfigMockJWTRefreshTokenTTL) Set(f func() (u1 uint64)) *ConfigMock {
	if mmJWTRefreshTokenTTL.defaultExpectation != nil {
		mmJWTRefreshTokenTTL.mock.t.Fatalf("Default expectation is already set for the config.JWTRefreshTokenTTL method")
	}

	if len(mmJWTRefreshTokenTTL.expectations) > 0 {
		mmJWTRefreshTokenTTL.mock.t.Fatalf("Some expectations are already set for the config.JWTRefreshTokenTTL method")
	}

	mmJWTRefreshTokenTTL.mock.funcJWTRefreshTokenTTL = f
	return mmJWTRefreshTokenTTL.mock
}

// JWTRefreshTokenTTL implements refreshtoken.config
func (mmJWTRefreshTokenTTL *ConfigMock) JWTRefreshTokenTTL() (u1 uint64) {
	mm_atomic.AddUint64(&mmJWTRefreshTokenTTL.beforeJWTRefreshTokenTTLCounter, 1)
	defer mm_atomic.AddUint64(&mmJWTRefreshTokenTTL.afterJWTRefreshTokenTTLCounter, 1)

	if mmJWTRefreshTokenTTL.inspectFuncJWTRefreshTokenTTL != nil {
		mmJWTRefreshTokenTTL.inspectFuncJWTRefreshTokenTTL()
	}

	if mmJWTRefreshTokenTTL.JWTRefreshTokenTTLMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmJWTRefreshTokenTTL.JWTRefreshTokenTTLMock.defaultExpectation.Counter, 1)

		mm_results := mmJWTRefreshTokenTTL.JWTRefreshTokenTTLMock.defaultExpectation.results
		if mm_results == nil {
			mmJWTRefreshTokenTTL.t.Fatal("No results are set for the ConfigMock.JWTRefreshTokenTTL")
		}
		return (*mm_results).u1
	}
	if mmJWTRefreshTokenTTL.funcJWTRefreshTokenTTL != nil {
		return mmJWTRefreshTokenTTL.funcJWTRefreshTokenTTL()
	}
	mmJWTRefreshTokenTTL.t.Fatalf("Unexpected call to ConfigMock.JWTRefreshTokenTTL.")
	return
}

// JWTRefreshTokenTTLAfterCounter returns a count of finished ConfigMock.JWTRefreshTokenTTL invocations
func (mmJWTRefreshTokenTTL *ConfigMock) JWTRefreshTokenTTLAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJWTRefreshTokenTTL.afterJWTRefreshTokenTTLCounter)
}

// JWTRefreshTokenTTLBeforeCounter returns a count of ConfigMock.JWTRefreshTokenTTL invocations
func (mmJWTRefreshTokenTTL *ConfigMock) JWTRefreshTokenTTLBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmJWTRefreshTokenTTL.beforeJWTRefreshTokenTTLCounter)
}

// MinimockJWTRefreshTokenTTLDone returns true if the count of the JWTRefreshTokenTTL invocations corresponds
// the number of defined expectations
func (m *ConfigMock) MinimockJWTRefreshTokenTTLDone() bool {
	for _, e := range m.JWTRefreshTokenTTLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JWTRefreshTokenTTLMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJWTRefreshTokenTTLCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJWTRefreshTokenTTL != nil && mm_atomic.LoadUint64(&m.afterJWTRefreshTokenTTLCounter) < 1 {
		return false
	}
	return true
}

// MinimockJWTRefreshTokenTTLInspect logs each unmet expectation
func (m *ConfigMock) MinimockJWTRefreshTokenTTLInspect() {
	for _, e := range m.JWTRefreshTokenTTLMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConfigMock.JWTRefreshTokenTTL")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.JWTRefreshTokenTTLMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterJWTRefreshTokenTTLCounter) < 1 {
		m.t.Error("Expected call to ConfigMock.JWTRefreshTokenTTL")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcJWTRefreshTokenTTL != nil && mm_atomic.LoadUint64(&m.afterJWTRefreshTokenTTLCounter) < 1 {
		m.t.Error("Expected call to ConfigMock.JWTRefreshTokenTTL")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConfigMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockJWTRefreshTokenTTLInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConfigMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConfigMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockJWTRefreshTokenTTLDone()
}
