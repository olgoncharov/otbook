package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/olgoncharov/otbook/internal/usecase/access/command/login.userRepo -o ./internal/usecase/access/command/login/mocks/user_repo_mock.go -n UserRepoMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	repoDTO "github.com/olgoncharov/otbook/internal/repository/dto"
)

// UserRepoMock implements login.userRepo
type UserRepoMock struct {
	t minimock.Tester

	funcGetPasswordHashByUsername          func(ctx context.Context, username string) (s1 string, err error)
	inspectFuncGetPasswordHashByUsername   func(ctx context.Context, username string)
	afterGetPasswordHashByUsernameCounter  uint64
	beforeGetPasswordHashByUsernameCounter uint64
	GetPasswordHashByUsernameMock          mUserRepoMockGetPasswordHashByUsername

	funcReplaceRefreshToken          func(ctx context.Context, username string, newToken repoDTO.RefreshToken) (err error)
	inspectFuncReplaceRefreshToken   func(ctx context.Context, username string, newToken repoDTO.RefreshToken)
	afterReplaceRefreshTokenCounter  uint64
	beforeReplaceRefreshTokenCounter uint64
	ReplaceRefreshTokenMock          mUserRepoMockReplaceRefreshToken
}

// NewUserRepoMock returns a mock for login.userRepo
func NewUserRepoMock(t minimock.Tester) *UserRepoMock {
	m := &UserRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetPasswordHashByUsernameMock = mUserRepoMockGetPasswordHashByUsername{mock: m}
	m.GetPasswordHashByUsernameMock.callArgs = []*UserRepoMockGetPasswordHashByUsernameParams{}

	m.ReplaceRefreshTokenMock = mUserRepoMockReplaceRefreshToken{mock: m}
	m.ReplaceRefreshTokenMock.callArgs = []*UserRepoMockReplaceRefreshTokenParams{}

	return m
}

type mUserRepoMockGetPasswordHashByUsername struct {
	mock               *UserRepoMock
	defaultExpectation *UserRepoMockGetPasswordHashByUsernameExpectation
	expectations       []*UserRepoMockGetPasswordHashByUsernameExpectation

	callArgs []*UserRepoMockGetPasswordHashByUsernameParams
	mutex    sync.RWMutex
}

// UserRepoMockGetPasswordHashByUsernameExpectation specifies expectation struct of the userRepo.GetPasswordHashByUsername
type UserRepoMockGetPasswordHashByUsernameExpectation struct {
	mock    *UserRepoMock
	params  *UserRepoMockGetPasswordHashByUsernameParams
	results *UserRepoMockGetPasswordHashByUsernameResults
	Counter uint64
}

// UserRepoMockGetPasswordHashByUsernameParams contains parameters of the userRepo.GetPasswordHashByUsername
type UserRepoMockGetPasswordHashByUsernameParams struct {
	ctx      context.Context
	username string
}

// UserRepoMockGetPasswordHashByUsernameResults contains results of the userRepo.GetPasswordHashByUsername
type UserRepoMockGetPasswordHashByUsernameResults struct {
	s1  string
	err error
}

// Expect sets up expected params for userRepo.GetPasswordHashByUsername
func (mmGetPasswordHashByUsername *mUserRepoMockGetPasswordHashByUsername) Expect(ctx context.Context, username string) *mUserRepoMockGetPasswordHashByUsername {
	if mmGetPasswordHashByUsername.mock.funcGetPasswordHashByUsername != nil {
		mmGetPasswordHashByUsername.mock.t.Fatalf("UserRepoMock.GetPasswordHashByUsername mock is already set by Set")
	}

	if mmGetPasswordHashByUsername.defaultExpectation == nil {
		mmGetPasswordHashByUsername.defaultExpectation = &UserRepoMockGetPasswordHashByUsernameExpectation{}
	}

	mmGetPasswordHashByUsername.defaultExpectation.params = &UserRepoMockGetPasswordHashByUsernameParams{ctx, username}
	for _, e := range mmGetPasswordHashByUsername.expectations {
		if minimock.Equal(e.params, mmGetPasswordHashByUsername.defaultExpectation.params) {
			mmGetPasswordHashByUsername.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPasswordHashByUsername.defaultExpectation.params)
		}
	}

	return mmGetPasswordHashByUsername
}

// Inspect accepts an inspector function that has same arguments as the userRepo.GetPasswordHashByUsername
func (mmGetPasswordHashByUsername *mUserRepoMockGetPasswordHashByUsername) Inspect(f func(ctx context.Context, username string)) *mUserRepoMockGetPasswordHashByUsername {
	if mmGetPasswordHashByUsername.mock.inspectFuncGetPasswordHashByUsername != nil {
		mmGetPasswordHashByUsername.mock.t.Fatalf("Inspect function is already set for UserRepoMock.GetPasswordHashByUsername")
	}

	mmGetPasswordHashByUsername.mock.inspectFuncGetPasswordHashByUsername = f

	return mmGetPasswordHashByUsername
}

// Return sets up results that will be returned by userRepo.GetPasswordHashByUsername
func (mmGetPasswordHashByUsername *mUserRepoMockGetPasswordHashByUsername) Return(s1 string, err error) *UserRepoMock {
	if mmGetPasswordHashByUsername.mock.funcGetPasswordHashByUsername != nil {
		mmGetPasswordHashByUsername.mock.t.Fatalf("UserRepoMock.GetPasswordHashByUsername mock is already set by Set")
	}

	if mmGetPasswordHashByUsername.defaultExpectation == nil {
		mmGetPasswordHashByUsername.defaultExpectation = &UserRepoMockGetPasswordHashByUsernameExpectation{mock: mmGetPasswordHashByUsername.mock}
	}
	mmGetPasswordHashByUsername.defaultExpectation.results = &UserRepoMockGetPasswordHashByUsernameResults{s1, err}
	return mmGetPasswordHashByUsername.mock
}

//Set uses given function f to mock the userRepo.GetPasswordHashByUsername method
func (mmGetPasswordHashByUsername *mUserRepoMockGetPasswordHashByUsername) Set(f func(ctx context.Context, username string) (s1 string, err error)) *UserRepoMock {
	if mmGetPasswordHashByUsername.defaultExpectation != nil {
		mmGetPasswordHashByUsername.mock.t.Fatalf("Default expectation is already set for the userRepo.GetPasswordHashByUsername method")
	}

	if len(mmGetPasswordHashByUsername.expectations) > 0 {
		mmGetPasswordHashByUsername.mock.t.Fatalf("Some expectations are already set for the userRepo.GetPasswordHashByUsername method")
	}

	mmGetPasswordHashByUsername.mock.funcGetPasswordHashByUsername = f
	return mmGetPasswordHashByUsername.mock
}

// When sets expectation for the userRepo.GetPasswordHashByUsername which will trigger the result defined by the following
// Then helper
func (mmGetPasswordHashByUsername *mUserRepoMockGetPasswordHashByUsername) When(ctx context.Context, username string) *UserRepoMockGetPasswordHashByUsernameExpectation {
	if mmGetPasswordHashByUsername.mock.funcGetPasswordHashByUsername != nil {
		mmGetPasswordHashByUsername.mock.t.Fatalf("UserRepoMock.GetPasswordHashByUsername mock is already set by Set")
	}

	expectation := &UserRepoMockGetPasswordHashByUsernameExpectation{
		mock:   mmGetPasswordHashByUsername.mock,
		params: &UserRepoMockGetPasswordHashByUsernameParams{ctx, username},
	}
	mmGetPasswordHashByUsername.expectations = append(mmGetPasswordHashByUsername.expectations, expectation)
	return expectation
}

// Then sets up userRepo.GetPasswordHashByUsername return parameters for the expectation previously defined by the When method
func (e *UserRepoMockGetPasswordHashByUsernameExpectation) Then(s1 string, err error) *UserRepoMock {
	e.results = &UserRepoMockGetPasswordHashByUsernameResults{s1, err}
	return e.mock
}

// GetPasswordHashByUsername implements login.userRepo
func (mmGetPasswordHashByUsername *UserRepoMock) GetPasswordHashByUsername(ctx context.Context, username string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetPasswordHashByUsername.beforeGetPasswordHashByUsernameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPasswordHashByUsername.afterGetPasswordHashByUsernameCounter, 1)

	if mmGetPasswordHashByUsername.inspectFuncGetPasswordHashByUsername != nil {
		mmGetPasswordHashByUsername.inspectFuncGetPasswordHashByUsername(ctx, username)
	}

	mm_params := &UserRepoMockGetPasswordHashByUsernameParams{ctx, username}

	// Record call args
	mmGetPasswordHashByUsername.GetPasswordHashByUsernameMock.mutex.Lock()
	mmGetPasswordHashByUsername.GetPasswordHashByUsernameMock.callArgs = append(mmGetPasswordHashByUsername.GetPasswordHashByUsernameMock.callArgs, mm_params)
	mmGetPasswordHashByUsername.GetPasswordHashByUsernameMock.mutex.Unlock()

	for _, e := range mmGetPasswordHashByUsername.GetPasswordHashByUsernameMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetPasswordHashByUsername.GetPasswordHashByUsernameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPasswordHashByUsername.GetPasswordHashByUsernameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPasswordHashByUsername.GetPasswordHashByUsernameMock.defaultExpectation.params
		mm_got := UserRepoMockGetPasswordHashByUsernameParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPasswordHashByUsername.t.Errorf("UserRepoMock.GetPasswordHashByUsername got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPasswordHashByUsername.GetPasswordHashByUsernameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPasswordHashByUsername.t.Fatal("No results are set for the UserRepoMock.GetPasswordHashByUsername")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetPasswordHashByUsername.funcGetPasswordHashByUsername != nil {
		return mmGetPasswordHashByUsername.funcGetPasswordHashByUsername(ctx, username)
	}
	mmGetPasswordHashByUsername.t.Fatalf("Unexpected call to UserRepoMock.GetPasswordHashByUsername. %v %v", ctx, username)
	return
}

// GetPasswordHashByUsernameAfterCounter returns a count of finished UserRepoMock.GetPasswordHashByUsername invocations
func (mmGetPasswordHashByUsername *UserRepoMock) GetPasswordHashByUsernameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPasswordHashByUsername.afterGetPasswordHashByUsernameCounter)
}

// GetPasswordHashByUsernameBeforeCounter returns a count of UserRepoMock.GetPasswordHashByUsername invocations
func (mmGetPasswordHashByUsername *UserRepoMock) GetPasswordHashByUsernameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPasswordHashByUsername.beforeGetPasswordHashByUsernameCounter)
}

// Calls returns a list of arguments used in each call to UserRepoMock.GetPasswordHashByUsername.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPasswordHashByUsername *mUserRepoMockGetPasswordHashByUsername) Calls() []*UserRepoMockGetPasswordHashByUsernameParams {
	mmGetPasswordHashByUsername.mutex.RLock()

	argCopy := make([]*UserRepoMockGetPasswordHashByUsernameParams, len(mmGetPasswordHashByUsername.callArgs))
	copy(argCopy, mmGetPasswordHashByUsername.callArgs)

	mmGetPasswordHashByUsername.mutex.RUnlock()

	return argCopy
}

// MinimockGetPasswordHashByUsernameDone returns true if the count of the GetPasswordHashByUsername invocations corresponds
// the number of defined expectations
func (m *UserRepoMock) MinimockGetPasswordHashByUsernameDone() bool {
	for _, e := range m.GetPasswordHashByUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPasswordHashByUsernameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPasswordHashByUsernameCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPasswordHashByUsername != nil && mm_atomic.LoadUint64(&m.afterGetPasswordHashByUsernameCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPasswordHashByUsernameInspect logs each unmet expectation
func (m *UserRepoMock) MinimockGetPasswordHashByUsernameInspect() {
	for _, e := range m.GetPasswordHashByUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepoMock.GetPasswordHashByUsername with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPasswordHashByUsernameMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPasswordHashByUsernameCounter) < 1 {
		if m.GetPasswordHashByUsernameMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepoMock.GetPasswordHashByUsername")
		} else {
			m.t.Errorf("Expected call to UserRepoMock.GetPasswordHashByUsername with params: %#v", *m.GetPasswordHashByUsernameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPasswordHashByUsername != nil && mm_atomic.LoadUint64(&m.afterGetPasswordHashByUsernameCounter) < 1 {
		m.t.Error("Expected call to UserRepoMock.GetPasswordHashByUsername")
	}
}

type mUserRepoMockReplaceRefreshToken struct {
	mock               *UserRepoMock
	defaultExpectation *UserRepoMockReplaceRefreshTokenExpectation
	expectations       []*UserRepoMockReplaceRefreshTokenExpectation

	callArgs []*UserRepoMockReplaceRefreshTokenParams
	mutex    sync.RWMutex
}

// UserRepoMockReplaceRefreshTokenExpectation specifies expectation struct of the userRepo.ReplaceRefreshToken
type UserRepoMockReplaceRefreshTokenExpectation struct {
	mock    *UserRepoMock
	params  *UserRepoMockReplaceRefreshTokenParams
	results *UserRepoMockReplaceRefreshTokenResults
	Counter uint64
}

// UserRepoMockReplaceRefreshTokenParams contains parameters of the userRepo.ReplaceRefreshToken
type UserRepoMockReplaceRefreshTokenParams struct {
	ctx      context.Context
	username string
	newToken repoDTO.RefreshToken
}

// UserRepoMockReplaceRefreshTokenResults contains results of the userRepo.ReplaceRefreshToken
type UserRepoMockReplaceRefreshTokenResults struct {
	err error
}

// Expect sets up expected params for userRepo.ReplaceRefreshToken
func (mmReplaceRefreshToken *mUserRepoMockReplaceRefreshToken) Expect(ctx context.Context, username string, newToken repoDTO.RefreshToken) *mUserRepoMockReplaceRefreshToken {
	if mmReplaceRefreshToken.mock.funcReplaceRefreshToken != nil {
		mmReplaceRefreshToken.mock.t.Fatalf("UserRepoMock.ReplaceRefreshToken mock is already set by Set")
	}

	if mmReplaceRefreshToken.defaultExpectation == nil {
		mmReplaceRefreshToken.defaultExpectation = &UserRepoMockReplaceRefreshTokenExpectation{}
	}

	mmReplaceRefreshToken.defaultExpectation.params = &UserRepoMockReplaceRefreshTokenParams{ctx, username, newToken}
	for _, e := range mmReplaceRefreshToken.expectations {
		if minimock.Equal(e.params, mmReplaceRefreshToken.defaultExpectation.params) {
			mmReplaceRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReplaceRefreshToken.defaultExpectation.params)
		}
	}

	return mmReplaceRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the userRepo.ReplaceRefreshToken
func (mmReplaceRefreshToken *mUserRepoMockReplaceRefreshToken) Inspect(f func(ctx context.Context, username string, newToken repoDTO.RefreshToken)) *mUserRepoMockReplaceRefreshToken {
	if mmReplaceRefreshToken.mock.inspectFuncReplaceRefreshToken != nil {
		mmReplaceRefreshToken.mock.t.Fatalf("Inspect function is already set for UserRepoMock.ReplaceRefreshToken")
	}

	mmReplaceRefreshToken.mock.inspectFuncReplaceRefreshToken = f

	return mmReplaceRefreshToken
}

// Return sets up results that will be returned by userRepo.ReplaceRefreshToken
func (mmReplaceRefreshToken *mUserRepoMockReplaceRefreshToken) Return(err error) *UserRepoMock {
	if mmReplaceRefreshToken.mock.funcReplaceRefreshToken != nil {
		mmReplaceRefreshToken.mock.t.Fatalf("UserRepoMock.ReplaceRefreshToken mock is already set by Set")
	}

	if mmReplaceRefreshToken.defaultExpectation == nil {
		mmReplaceRefreshToken.defaultExpectation = &UserRepoMockReplaceRefreshTokenExpectation{mock: mmReplaceRefreshToken.mock}
	}
	mmReplaceRefreshToken.defaultExpectation.results = &UserRepoMockReplaceRefreshTokenResults{err}
	return mmReplaceRefreshToken.mock
}

//Set uses given function f to mock the userRepo.ReplaceRefreshToken method
func (mmReplaceRefreshToken *mUserRepoMockReplaceRefreshToken) Set(f func(ctx context.Context, username string, newToken repoDTO.RefreshToken) (err error)) *UserRepoMock {
	if mmReplaceRefreshToken.defaultExpectation != nil {
		mmReplaceRefreshToken.mock.t.Fatalf("Default expectation is already set for the userRepo.ReplaceRefreshToken method")
	}

	if len(mmReplaceRefreshToken.expectations) > 0 {
		mmReplaceRefreshToken.mock.t.Fatalf("Some expectations are already set for the userRepo.ReplaceRefreshToken method")
	}

	mmReplaceRefreshToken.mock.funcReplaceRefreshToken = f
	return mmReplaceRefreshToken.mock
}

// When sets expectation for the userRepo.ReplaceRefreshToken which will trigger the result defined by the following
// Then helper
func (mmReplaceRefreshToken *mUserRepoMockReplaceRefreshToken) When(ctx context.Context, username string, newToken repoDTO.RefreshToken) *UserRepoMockReplaceRefreshTokenExpectation {
	if mmReplaceRefreshToken.mock.funcReplaceRefreshToken != nil {
		mmReplaceRefreshToken.mock.t.Fatalf("UserRepoMock.ReplaceRefreshToken mock is already set by Set")
	}

	expectation := &UserRepoMockReplaceRefreshTokenExpectation{
		mock:   mmReplaceRefreshToken.mock,
		params: &UserRepoMockReplaceRefreshTokenParams{ctx, username, newToken},
	}
	mmReplaceRefreshToken.expectations = append(mmReplaceRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up userRepo.ReplaceRefreshToken return parameters for the expectation previously defined by the When method
func (e *UserRepoMockReplaceRefreshTokenExpectation) Then(err error) *UserRepoMock {
	e.results = &UserRepoMockReplaceRefreshTokenResults{err}
	return e.mock
}

// ReplaceRefreshToken implements login.userRepo
func (mmReplaceRefreshToken *UserRepoMock) ReplaceRefreshToken(ctx context.Context, username string, newToken repoDTO.RefreshToken) (err error) {
	mm_atomic.AddUint64(&mmReplaceRefreshToken.beforeReplaceRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmReplaceRefreshToken.afterReplaceRefreshTokenCounter, 1)

	if mmReplaceRefreshToken.inspectFuncReplaceRefreshToken != nil {
		mmReplaceRefreshToken.inspectFuncReplaceRefreshToken(ctx, username, newToken)
	}

	mm_params := &UserRepoMockReplaceRefreshTokenParams{ctx, username, newToken}

	// Record call args
	mmReplaceRefreshToken.ReplaceRefreshTokenMock.mutex.Lock()
	mmReplaceRefreshToken.ReplaceRefreshTokenMock.callArgs = append(mmReplaceRefreshToken.ReplaceRefreshTokenMock.callArgs, mm_params)
	mmReplaceRefreshToken.ReplaceRefreshTokenMock.mutex.Unlock()

	for _, e := range mmReplaceRefreshToken.ReplaceRefreshTokenMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReplaceRefreshToken.ReplaceRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReplaceRefreshToken.ReplaceRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmReplaceRefreshToken.ReplaceRefreshTokenMock.defaultExpectation.params
		mm_got := UserRepoMockReplaceRefreshTokenParams{ctx, username, newToken}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReplaceRefreshToken.t.Errorf("UserRepoMock.ReplaceRefreshToken got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReplaceRefreshToken.ReplaceRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmReplaceRefreshToken.t.Fatal("No results are set for the UserRepoMock.ReplaceRefreshToken")
		}
		return (*mm_results).err
	}
	if mmReplaceRefreshToken.funcReplaceRefreshToken != nil {
		return mmReplaceRefreshToken.funcReplaceRefreshToken(ctx, username, newToken)
	}
	mmReplaceRefreshToken.t.Fatalf("Unexpected call to UserRepoMock.ReplaceRefreshToken. %v %v %v", ctx, username, newToken)
	return
}

// ReplaceRefreshTokenAfterCounter returns a count of finished UserRepoMock.ReplaceRefreshToken invocations
func (mmReplaceRefreshToken *UserRepoMock) ReplaceRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReplaceRefreshToken.afterReplaceRefreshTokenCounter)
}

// ReplaceRefreshTokenBeforeCounter returns a count of UserRepoMock.ReplaceRefreshToken invocations
func (mmReplaceRefreshToken *UserRepoMock) ReplaceRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReplaceRefreshToken.beforeReplaceRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to UserRepoMock.ReplaceRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReplaceRefreshToken *mUserRepoMockReplaceRefreshToken) Calls() []*UserRepoMockReplaceRefreshTokenParams {
	mmReplaceRefreshToken.mutex.RLock()

	argCopy := make([]*UserRepoMockReplaceRefreshTokenParams, len(mmReplaceRefreshToken.callArgs))
	copy(argCopy, mmReplaceRefreshToken.callArgs)

	mmReplaceRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockReplaceRefreshTokenDone returns true if the count of the ReplaceRefreshToken invocations corresponds
// the number of defined expectations
func (m *UserRepoMock) MinimockReplaceRefreshTokenDone() bool {
	for _, e := range m.ReplaceRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReplaceRefreshTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReplaceRefreshTokenCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReplaceRefreshToken != nil && mm_atomic.LoadUint64(&m.afterReplaceRefreshTokenCounter) < 1 {
		return false
	}
	return true
}

// MinimockReplaceRefreshTokenInspect logs each unmet expectation
func (m *UserRepoMock) MinimockReplaceRefreshTokenInspect() {
	for _, e := range m.ReplaceRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepoMock.ReplaceRefreshToken with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReplaceRefreshTokenMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReplaceRefreshTokenCounter) < 1 {
		if m.ReplaceRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserRepoMock.ReplaceRefreshToken")
		} else {
			m.t.Errorf("Expected call to UserRepoMock.ReplaceRefreshToken with params: %#v", *m.ReplaceRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReplaceRefreshToken != nil && mm_atomic.LoadUint64(&m.afterReplaceRefreshTokenCounter) < 1 {
		m.t.Error("Expected call to UserRepoMock.ReplaceRefreshToken")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetPasswordHashByUsernameInspect()

		m.MinimockReplaceRefreshTokenInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetPasswordHashByUsernameDone() &&
		m.MinimockReplaceRefreshTokenDone()
}
