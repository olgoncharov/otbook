package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/olgoncharov/otbook/internal/usecase/profile/command/update.profileRepo -o ./internal/usecase/profile/command/update/mocks/profile_repo_mock.go -n ProfileRepoMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/olgoncharov/otbook/internal/entity"
)

// ProfileRepoMock implements update.profileRepo
type ProfileRepoMock struct {
	t minimock.Tester

	funcCheckUsersExistence          func(ctx context.Context, usernames ...string) (m1 map[string]bool, err error)
	inspectFuncCheckUsersExistence   func(ctx context.Context, usernames ...string)
	afterCheckUsersExistenceCounter  uint64
	beforeCheckUsersExistenceCounter uint64
	CheckUsersExistenceMock          mProfileRepoMockCheckUsersExistence

	funcUpdateProfile          func(ctx context.Context, profile entity.Profile) (err error)
	inspectFuncUpdateProfile   func(ctx context.Context, profile entity.Profile)
	afterUpdateProfileCounter  uint64
	beforeUpdateProfileCounter uint64
	UpdateProfileMock          mProfileRepoMockUpdateProfile
}

// NewProfileRepoMock returns a mock for update.profileRepo
func NewProfileRepoMock(t minimock.Tester) *ProfileRepoMock {
	m := &ProfileRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckUsersExistenceMock = mProfileRepoMockCheckUsersExistence{mock: m}
	m.CheckUsersExistenceMock.callArgs = []*ProfileRepoMockCheckUsersExistenceParams{}

	m.UpdateProfileMock = mProfileRepoMockUpdateProfile{mock: m}
	m.UpdateProfileMock.callArgs = []*ProfileRepoMockUpdateProfileParams{}

	return m
}

type mProfileRepoMockCheckUsersExistence struct {
	mock               *ProfileRepoMock
	defaultExpectation *ProfileRepoMockCheckUsersExistenceExpectation
	expectations       []*ProfileRepoMockCheckUsersExistenceExpectation

	callArgs []*ProfileRepoMockCheckUsersExistenceParams
	mutex    sync.RWMutex
}

// ProfileRepoMockCheckUsersExistenceExpectation specifies expectation struct of the profileRepo.CheckUsersExistence
type ProfileRepoMockCheckUsersExistenceExpectation struct {
	mock    *ProfileRepoMock
	params  *ProfileRepoMockCheckUsersExistenceParams
	results *ProfileRepoMockCheckUsersExistenceResults
	Counter uint64
}

// ProfileRepoMockCheckUsersExistenceParams contains parameters of the profileRepo.CheckUsersExistence
type ProfileRepoMockCheckUsersExistenceParams struct {
	ctx       context.Context
	usernames []string
}

// ProfileRepoMockCheckUsersExistenceResults contains results of the profileRepo.CheckUsersExistence
type ProfileRepoMockCheckUsersExistenceResults struct {
	m1  map[string]bool
	err error
}

// Expect sets up expected params for profileRepo.CheckUsersExistence
func (mmCheckUsersExistence *mProfileRepoMockCheckUsersExistence) Expect(ctx context.Context, usernames ...string) *mProfileRepoMockCheckUsersExistence {
	if mmCheckUsersExistence.mock.funcCheckUsersExistence != nil {
		mmCheckUsersExistence.mock.t.Fatalf("ProfileRepoMock.CheckUsersExistence mock is already set by Set")
	}

	if mmCheckUsersExistence.defaultExpectation == nil {
		mmCheckUsersExistence.defaultExpectation = &ProfileRepoMockCheckUsersExistenceExpectation{}
	}

	mmCheckUsersExistence.defaultExpectation.params = &ProfileRepoMockCheckUsersExistenceParams{ctx, usernames}
	for _, e := range mmCheckUsersExistence.expectations {
		if minimock.Equal(e.params, mmCheckUsersExistence.defaultExpectation.params) {
			mmCheckUsersExistence.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckUsersExistence.defaultExpectation.params)
		}
	}

	return mmCheckUsersExistence
}

// Inspect accepts an inspector function that has same arguments as the profileRepo.CheckUsersExistence
func (mmCheckUsersExistence *mProfileRepoMockCheckUsersExistence) Inspect(f func(ctx context.Context, usernames ...string)) *mProfileRepoMockCheckUsersExistence {
	if mmCheckUsersExistence.mock.inspectFuncCheckUsersExistence != nil {
		mmCheckUsersExistence.mock.t.Fatalf("Inspect function is already set for ProfileRepoMock.CheckUsersExistence")
	}

	mmCheckUsersExistence.mock.inspectFuncCheckUsersExistence = f

	return mmCheckUsersExistence
}

// Return sets up results that will be returned by profileRepo.CheckUsersExistence
func (mmCheckUsersExistence *mProfileRepoMockCheckUsersExistence) Return(m1 map[string]bool, err error) *ProfileRepoMock {
	if mmCheckUsersExistence.mock.funcCheckUsersExistence != nil {
		mmCheckUsersExistence.mock.t.Fatalf("ProfileRepoMock.CheckUsersExistence mock is already set by Set")
	}

	if mmCheckUsersExistence.defaultExpectation == nil {
		mmCheckUsersExistence.defaultExpectation = &ProfileRepoMockCheckUsersExistenceExpectation{mock: mmCheckUsersExistence.mock}
	}
	mmCheckUsersExistence.defaultExpectation.results = &ProfileRepoMockCheckUsersExistenceResults{m1, err}
	return mmCheckUsersExistence.mock
}

//Set uses given function f to mock the profileRepo.CheckUsersExistence method
func (mmCheckUsersExistence *mProfileRepoMockCheckUsersExistence) Set(f func(ctx context.Context, usernames ...string) (m1 map[string]bool, err error)) *ProfileRepoMock {
	if mmCheckUsersExistence.defaultExpectation != nil {
		mmCheckUsersExistence.mock.t.Fatalf("Default expectation is already set for the profileRepo.CheckUsersExistence method")
	}

	if len(mmCheckUsersExistence.expectations) > 0 {
		mmCheckUsersExistence.mock.t.Fatalf("Some expectations are already set for the profileRepo.CheckUsersExistence method")
	}

	mmCheckUsersExistence.mock.funcCheckUsersExistence = f
	return mmCheckUsersExistence.mock
}

// When sets expectation for the profileRepo.CheckUsersExistence which will trigger the result defined by the following
// Then helper
func (mmCheckUsersExistence *mProfileRepoMockCheckUsersExistence) When(ctx context.Context, usernames ...string) *ProfileRepoMockCheckUsersExistenceExpectation {
	if mmCheckUsersExistence.mock.funcCheckUsersExistence != nil {
		mmCheckUsersExistence.mock.t.Fatalf("ProfileRepoMock.CheckUsersExistence mock is already set by Set")
	}

	expectation := &ProfileRepoMockCheckUsersExistenceExpectation{
		mock:   mmCheckUsersExistence.mock,
		params: &ProfileRepoMockCheckUsersExistenceParams{ctx, usernames},
	}
	mmCheckUsersExistence.expectations = append(mmCheckUsersExistence.expectations, expectation)
	return expectation
}

// Then sets up profileRepo.CheckUsersExistence return parameters for the expectation previously defined by the When method
func (e *ProfileRepoMockCheckUsersExistenceExpectation) Then(m1 map[string]bool, err error) *ProfileRepoMock {
	e.results = &ProfileRepoMockCheckUsersExistenceResults{m1, err}
	return e.mock
}

// CheckUsersExistence implements update.profileRepo
func (mmCheckUsersExistence *ProfileRepoMock) CheckUsersExistence(ctx context.Context, usernames ...string) (m1 map[string]bool, err error) {
	mm_atomic.AddUint64(&mmCheckUsersExistence.beforeCheckUsersExistenceCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckUsersExistence.afterCheckUsersExistenceCounter, 1)

	if mmCheckUsersExistence.inspectFuncCheckUsersExistence != nil {
		mmCheckUsersExistence.inspectFuncCheckUsersExistence(ctx, usernames...)
	}

	mm_params := &ProfileRepoMockCheckUsersExistenceParams{ctx, usernames}

	// Record call args
	mmCheckUsersExistence.CheckUsersExistenceMock.mutex.Lock()
	mmCheckUsersExistence.CheckUsersExistenceMock.callArgs = append(mmCheckUsersExistence.CheckUsersExistenceMock.callArgs, mm_params)
	mmCheckUsersExistence.CheckUsersExistenceMock.mutex.Unlock()

	for _, e := range mmCheckUsersExistence.CheckUsersExistenceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmCheckUsersExistence.CheckUsersExistenceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckUsersExistence.CheckUsersExistenceMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckUsersExistence.CheckUsersExistenceMock.defaultExpectation.params
		mm_got := ProfileRepoMockCheckUsersExistenceParams{ctx, usernames}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckUsersExistence.t.Errorf("ProfileRepoMock.CheckUsersExistence got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckUsersExistence.CheckUsersExistenceMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckUsersExistence.t.Fatal("No results are set for the ProfileRepoMock.CheckUsersExistence")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmCheckUsersExistence.funcCheckUsersExistence != nil {
		return mmCheckUsersExistence.funcCheckUsersExistence(ctx, usernames...)
	}
	mmCheckUsersExistence.t.Fatalf("Unexpected call to ProfileRepoMock.CheckUsersExistence. %v %v", ctx, usernames)
	return
}

// CheckUsersExistenceAfterCounter returns a count of finished ProfileRepoMock.CheckUsersExistence invocations
func (mmCheckUsersExistence *ProfileRepoMock) CheckUsersExistenceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckUsersExistence.afterCheckUsersExistenceCounter)
}

// CheckUsersExistenceBeforeCounter returns a count of ProfileRepoMock.CheckUsersExistence invocations
func (mmCheckUsersExistence *ProfileRepoMock) CheckUsersExistenceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckUsersExistence.beforeCheckUsersExistenceCounter)
}

// Calls returns a list of arguments used in each call to ProfileRepoMock.CheckUsersExistence.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckUsersExistence *mProfileRepoMockCheckUsersExistence) Calls() []*ProfileRepoMockCheckUsersExistenceParams {
	mmCheckUsersExistence.mutex.RLock()

	argCopy := make([]*ProfileRepoMockCheckUsersExistenceParams, len(mmCheckUsersExistence.callArgs))
	copy(argCopy, mmCheckUsersExistence.callArgs)

	mmCheckUsersExistence.mutex.RUnlock()

	return argCopy
}

// MinimockCheckUsersExistenceDone returns true if the count of the CheckUsersExistence invocations corresponds
// the number of defined expectations
func (m *ProfileRepoMock) MinimockCheckUsersExistenceDone() bool {
	for _, e := range m.CheckUsersExistenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckUsersExistenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckUsersExistenceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckUsersExistence != nil && mm_atomic.LoadUint64(&m.afterCheckUsersExistenceCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckUsersExistenceInspect logs each unmet expectation
func (m *ProfileRepoMock) MinimockCheckUsersExistenceInspect() {
	for _, e := range m.CheckUsersExistenceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProfileRepoMock.CheckUsersExistence with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckUsersExistenceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckUsersExistenceCounter) < 1 {
		if m.CheckUsersExistenceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProfileRepoMock.CheckUsersExistence")
		} else {
			m.t.Errorf("Expected call to ProfileRepoMock.CheckUsersExistence with params: %#v", *m.CheckUsersExistenceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckUsersExistence != nil && mm_atomic.LoadUint64(&m.afterCheckUsersExistenceCounter) < 1 {
		m.t.Error("Expected call to ProfileRepoMock.CheckUsersExistence")
	}
}

type mProfileRepoMockUpdateProfile struct {
	mock               *ProfileRepoMock
	defaultExpectation *ProfileRepoMockUpdateProfileExpectation
	expectations       []*ProfileRepoMockUpdateProfileExpectation

	callArgs []*ProfileRepoMockUpdateProfileParams
	mutex    sync.RWMutex
}

// ProfileRepoMockUpdateProfileExpectation specifies expectation struct of the profileRepo.UpdateProfile
type ProfileRepoMockUpdateProfileExpectation struct {
	mock    *ProfileRepoMock
	params  *ProfileRepoMockUpdateProfileParams
	results *ProfileRepoMockUpdateProfileResults
	Counter uint64
}

// ProfileRepoMockUpdateProfileParams contains parameters of the profileRepo.UpdateProfile
type ProfileRepoMockUpdateProfileParams struct {
	ctx     context.Context
	profile entity.Profile
}

// ProfileRepoMockUpdateProfileResults contains results of the profileRepo.UpdateProfile
type ProfileRepoMockUpdateProfileResults struct {
	err error
}

// Expect sets up expected params for profileRepo.UpdateProfile
func (mmUpdateProfile *mProfileRepoMockUpdateProfile) Expect(ctx context.Context, profile entity.Profile) *mProfileRepoMockUpdateProfile {
	if mmUpdateProfile.mock.funcUpdateProfile != nil {
		mmUpdateProfile.mock.t.Fatalf("ProfileRepoMock.UpdateProfile mock is already set by Set")
	}

	if mmUpdateProfile.defaultExpectation == nil {
		mmUpdateProfile.defaultExpectation = &ProfileRepoMockUpdateProfileExpectation{}
	}

	mmUpdateProfile.defaultExpectation.params = &ProfileRepoMockUpdateProfileParams{ctx, profile}
	for _, e := range mmUpdateProfile.expectations {
		if minimock.Equal(e.params, mmUpdateProfile.defaultExpectation.params) {
			mmUpdateProfile.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateProfile.defaultExpectation.params)
		}
	}

	return mmUpdateProfile
}

// Inspect accepts an inspector function that has same arguments as the profileRepo.UpdateProfile
func (mmUpdateProfile *mProfileRepoMockUpdateProfile) Inspect(f func(ctx context.Context, profile entity.Profile)) *mProfileRepoMockUpdateProfile {
	if mmUpdateProfile.mock.inspectFuncUpdateProfile != nil {
		mmUpdateProfile.mock.t.Fatalf("Inspect function is already set for ProfileRepoMock.UpdateProfile")
	}

	mmUpdateProfile.mock.inspectFuncUpdateProfile = f

	return mmUpdateProfile
}

// Return sets up results that will be returned by profileRepo.UpdateProfile
func (mmUpdateProfile *mProfileRepoMockUpdateProfile) Return(err error) *ProfileRepoMock {
	if mmUpdateProfile.mock.funcUpdateProfile != nil {
		mmUpdateProfile.mock.t.Fatalf("ProfileRepoMock.UpdateProfile mock is already set by Set")
	}

	if mmUpdateProfile.defaultExpectation == nil {
		mmUpdateProfile.defaultExpectation = &ProfileRepoMockUpdateProfileExpectation{mock: mmUpdateProfile.mock}
	}
	mmUpdateProfile.defaultExpectation.results = &ProfileRepoMockUpdateProfileResults{err}
	return mmUpdateProfile.mock
}

//Set uses given function f to mock the profileRepo.UpdateProfile method
func (mmUpdateProfile *mProfileRepoMockUpdateProfile) Set(f func(ctx context.Context, profile entity.Profile) (err error)) *ProfileRepoMock {
	if mmUpdateProfile.defaultExpectation != nil {
		mmUpdateProfile.mock.t.Fatalf("Default expectation is already set for the profileRepo.UpdateProfile method")
	}

	if len(mmUpdateProfile.expectations) > 0 {
		mmUpdateProfile.mock.t.Fatalf("Some expectations are already set for the profileRepo.UpdateProfile method")
	}

	mmUpdateProfile.mock.funcUpdateProfile = f
	return mmUpdateProfile.mock
}

// When sets expectation for the profileRepo.UpdateProfile which will trigger the result defined by the following
// Then helper
func (mmUpdateProfile *mProfileRepoMockUpdateProfile) When(ctx context.Context, profile entity.Profile) *ProfileRepoMockUpdateProfileExpectation {
	if mmUpdateProfile.mock.funcUpdateProfile != nil {
		mmUpdateProfile.mock.t.Fatalf("ProfileRepoMock.UpdateProfile mock is already set by Set")
	}

	expectation := &ProfileRepoMockUpdateProfileExpectation{
		mock:   mmUpdateProfile.mock,
		params: &ProfileRepoMockUpdateProfileParams{ctx, profile},
	}
	mmUpdateProfile.expectations = append(mmUpdateProfile.expectations, expectation)
	return expectation
}

// Then sets up profileRepo.UpdateProfile return parameters for the expectation previously defined by the When method
func (e *ProfileRepoMockUpdateProfileExpectation) Then(err error) *ProfileRepoMock {
	e.results = &ProfileRepoMockUpdateProfileResults{err}
	return e.mock
}

// UpdateProfile implements update.profileRepo
func (mmUpdateProfile *ProfileRepoMock) UpdateProfile(ctx context.Context, profile entity.Profile) (err error) {
	mm_atomic.AddUint64(&mmUpdateProfile.beforeUpdateProfileCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateProfile.afterUpdateProfileCounter, 1)

	if mmUpdateProfile.inspectFuncUpdateProfile != nil {
		mmUpdateProfile.inspectFuncUpdateProfile(ctx, profile)
	}

	mm_params := &ProfileRepoMockUpdateProfileParams{ctx, profile}

	// Record call args
	mmUpdateProfile.UpdateProfileMock.mutex.Lock()
	mmUpdateProfile.UpdateProfileMock.callArgs = append(mmUpdateProfile.UpdateProfileMock.callArgs, mm_params)
	mmUpdateProfile.UpdateProfileMock.mutex.Unlock()

	for _, e := range mmUpdateProfile.UpdateProfileMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateProfile.UpdateProfileMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateProfile.UpdateProfileMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateProfile.UpdateProfileMock.defaultExpectation.params
		mm_got := ProfileRepoMockUpdateProfileParams{ctx, profile}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateProfile.t.Errorf("ProfileRepoMock.UpdateProfile got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateProfile.UpdateProfileMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateProfile.t.Fatal("No results are set for the ProfileRepoMock.UpdateProfile")
		}
		return (*mm_results).err
	}
	if mmUpdateProfile.funcUpdateProfile != nil {
		return mmUpdateProfile.funcUpdateProfile(ctx, profile)
	}
	mmUpdateProfile.t.Fatalf("Unexpected call to ProfileRepoMock.UpdateProfile. %v %v", ctx, profile)
	return
}

// UpdateProfileAfterCounter returns a count of finished ProfileRepoMock.UpdateProfile invocations
func (mmUpdateProfile *ProfileRepoMock) UpdateProfileAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateProfile.afterUpdateProfileCounter)
}

// UpdateProfileBeforeCounter returns a count of ProfileRepoMock.UpdateProfile invocations
func (mmUpdateProfile *ProfileRepoMock) UpdateProfileBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateProfile.beforeUpdateProfileCounter)
}

// Calls returns a list of arguments used in each call to ProfileRepoMock.UpdateProfile.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateProfile *mProfileRepoMockUpdateProfile) Calls() []*ProfileRepoMockUpdateProfileParams {
	mmUpdateProfile.mutex.RLock()

	argCopy := make([]*ProfileRepoMockUpdateProfileParams, len(mmUpdateProfile.callArgs))
	copy(argCopy, mmUpdateProfile.callArgs)

	mmUpdateProfile.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateProfileDone returns true if the count of the UpdateProfile invocations corresponds
// the number of defined expectations
func (m *ProfileRepoMock) MinimockUpdateProfileDone() bool {
	for _, e := range m.UpdateProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateProfileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateProfileCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateProfile != nil && mm_atomic.LoadUint64(&m.afterUpdateProfileCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateProfileInspect logs each unmet expectation
func (m *ProfileRepoMock) MinimockUpdateProfileInspect() {
	for _, e := range m.UpdateProfileMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProfileRepoMock.UpdateProfile with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateProfileMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateProfileCounter) < 1 {
		if m.UpdateProfileMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProfileRepoMock.UpdateProfile")
		} else {
			m.t.Errorf("Expected call to ProfileRepoMock.UpdateProfile with params: %#v", *m.UpdateProfileMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateProfile != nil && mm_atomic.LoadUint64(&m.afterUpdateProfileCounter) < 1 {
		m.t.Error("Expected call to ProfileRepoMock.UpdateProfile")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProfileRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCheckUsersExistenceInspect()

		m.MinimockUpdateProfileInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProfileRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProfileRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckUsersExistenceDone() &&
		m.MinimockUpdateProfileDone()
}
