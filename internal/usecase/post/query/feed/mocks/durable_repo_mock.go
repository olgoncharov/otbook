package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/olgoncharov/otbook/internal/usecase/post/query/feed.durableRepo -o ./internal/usecase/post/query/feed/mocks/durable_repo_mock.go -n DurableRepoMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/olgoncharov/otbook/internal/repository/dto"
)

// DurableRepoMock implements feed.durableRepo
type DurableRepoMock struct {
	t minimock.Tester

	funcGetCelebrityFriends          func(ctx context.Context, username string) (sa1 []string, err error)
	inspectFuncGetCelebrityFriends   func(ctx context.Context, username string)
	afterGetCelebrityFriendsCounter  uint64
	beforeGetCelebrityFriendsCounter uint64
	GetCelebrityFriendsMock          mDurableRepoMockGetCelebrityFriends

	funcGetPostFeed          func(ctx context.Context, username string, limit uint) (pa1 []dto.PostShortInfo, err error)
	inspectFuncGetPostFeed   func(ctx context.Context, username string, limit uint)
	afterGetPostFeedCounter  uint64
	beforeGetPostFeedCounter uint64
	GetPostFeedMock          mDurableRepoMockGetPostFeed

	funcGetPostsByFilters          func(ctx context.Context, filters dto.PostFilters, limit uint, offset uint) (pa1 []dto.PostShortInfo, err error)
	inspectFuncGetPostsByFilters   func(ctx context.Context, filters dto.PostFilters, limit uint, offset uint)
	afterGetPostsByFiltersCounter  uint64
	beforeGetPostsByFiltersCounter uint64
	GetPostsByFiltersMock          mDurableRepoMockGetPostsByFilters
}

// NewDurableRepoMock returns a mock for feed.durableRepo
func NewDurableRepoMock(t minimock.Tester) *DurableRepoMock {
	m := &DurableRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCelebrityFriendsMock = mDurableRepoMockGetCelebrityFriends{mock: m}
	m.GetCelebrityFriendsMock.callArgs = []*DurableRepoMockGetCelebrityFriendsParams{}

	m.GetPostFeedMock = mDurableRepoMockGetPostFeed{mock: m}
	m.GetPostFeedMock.callArgs = []*DurableRepoMockGetPostFeedParams{}

	m.GetPostsByFiltersMock = mDurableRepoMockGetPostsByFilters{mock: m}
	m.GetPostsByFiltersMock.callArgs = []*DurableRepoMockGetPostsByFiltersParams{}

	return m
}

type mDurableRepoMockGetCelebrityFriends struct {
	mock               *DurableRepoMock
	defaultExpectation *DurableRepoMockGetCelebrityFriendsExpectation
	expectations       []*DurableRepoMockGetCelebrityFriendsExpectation

	callArgs []*DurableRepoMockGetCelebrityFriendsParams
	mutex    sync.RWMutex
}

// DurableRepoMockGetCelebrityFriendsExpectation specifies expectation struct of the durableRepo.GetCelebrityFriends
type DurableRepoMockGetCelebrityFriendsExpectation struct {
	mock    *DurableRepoMock
	params  *DurableRepoMockGetCelebrityFriendsParams
	results *DurableRepoMockGetCelebrityFriendsResults
	Counter uint64
}

// DurableRepoMockGetCelebrityFriendsParams contains parameters of the durableRepo.GetCelebrityFriends
type DurableRepoMockGetCelebrityFriendsParams struct {
	ctx      context.Context
	username string
}

// DurableRepoMockGetCelebrityFriendsResults contains results of the durableRepo.GetCelebrityFriends
type DurableRepoMockGetCelebrityFriendsResults struct {
	sa1 []string
	err error
}

// Expect sets up expected params for durableRepo.GetCelebrityFriends
func (mmGetCelebrityFriends *mDurableRepoMockGetCelebrityFriends) Expect(ctx context.Context, username string) *mDurableRepoMockGetCelebrityFriends {
	if mmGetCelebrityFriends.mock.funcGetCelebrityFriends != nil {
		mmGetCelebrityFriends.mock.t.Fatalf("DurableRepoMock.GetCelebrityFriends mock is already set by Set")
	}

	if mmGetCelebrityFriends.defaultExpectation == nil {
		mmGetCelebrityFriends.defaultExpectation = &DurableRepoMockGetCelebrityFriendsExpectation{}
	}

	mmGetCelebrityFriends.defaultExpectation.params = &DurableRepoMockGetCelebrityFriendsParams{ctx, username}
	for _, e := range mmGetCelebrityFriends.expectations {
		if minimock.Equal(e.params, mmGetCelebrityFriends.defaultExpectation.params) {
			mmGetCelebrityFriends.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCelebrityFriends.defaultExpectation.params)
		}
	}

	return mmGetCelebrityFriends
}

// Inspect accepts an inspector function that has same arguments as the durableRepo.GetCelebrityFriends
func (mmGetCelebrityFriends *mDurableRepoMockGetCelebrityFriends) Inspect(f func(ctx context.Context, username string)) *mDurableRepoMockGetCelebrityFriends {
	if mmGetCelebrityFriends.mock.inspectFuncGetCelebrityFriends != nil {
		mmGetCelebrityFriends.mock.t.Fatalf("Inspect function is already set for DurableRepoMock.GetCelebrityFriends")
	}

	mmGetCelebrityFriends.mock.inspectFuncGetCelebrityFriends = f

	return mmGetCelebrityFriends
}

// Return sets up results that will be returned by durableRepo.GetCelebrityFriends
func (mmGetCelebrityFriends *mDurableRepoMockGetCelebrityFriends) Return(sa1 []string, err error) *DurableRepoMock {
	if mmGetCelebrityFriends.mock.funcGetCelebrityFriends != nil {
		mmGetCelebrityFriends.mock.t.Fatalf("DurableRepoMock.GetCelebrityFriends mock is already set by Set")
	}

	if mmGetCelebrityFriends.defaultExpectation == nil {
		mmGetCelebrityFriends.defaultExpectation = &DurableRepoMockGetCelebrityFriendsExpectation{mock: mmGetCelebrityFriends.mock}
	}
	mmGetCelebrityFriends.defaultExpectation.results = &DurableRepoMockGetCelebrityFriendsResults{sa1, err}
	return mmGetCelebrityFriends.mock
}

//Set uses given function f to mock the durableRepo.GetCelebrityFriends method
func (mmGetCelebrityFriends *mDurableRepoMockGetCelebrityFriends) Set(f func(ctx context.Context, username string) (sa1 []string, err error)) *DurableRepoMock {
	if mmGetCelebrityFriends.defaultExpectation != nil {
		mmGetCelebrityFriends.mock.t.Fatalf("Default expectation is already set for the durableRepo.GetCelebrityFriends method")
	}

	if len(mmGetCelebrityFriends.expectations) > 0 {
		mmGetCelebrityFriends.mock.t.Fatalf("Some expectations are already set for the durableRepo.GetCelebrityFriends method")
	}

	mmGetCelebrityFriends.mock.funcGetCelebrityFriends = f
	return mmGetCelebrityFriends.mock
}

// When sets expectation for the durableRepo.GetCelebrityFriends which will trigger the result defined by the following
// Then helper
func (mmGetCelebrityFriends *mDurableRepoMockGetCelebrityFriends) When(ctx context.Context, username string) *DurableRepoMockGetCelebrityFriendsExpectation {
	if mmGetCelebrityFriends.mock.funcGetCelebrityFriends != nil {
		mmGetCelebrityFriends.mock.t.Fatalf("DurableRepoMock.GetCelebrityFriends mock is already set by Set")
	}

	expectation := &DurableRepoMockGetCelebrityFriendsExpectation{
		mock:   mmGetCelebrityFriends.mock,
		params: &DurableRepoMockGetCelebrityFriendsParams{ctx, username},
	}
	mmGetCelebrityFriends.expectations = append(mmGetCelebrityFriends.expectations, expectation)
	return expectation
}

// Then sets up durableRepo.GetCelebrityFriends return parameters for the expectation previously defined by the When method
func (e *DurableRepoMockGetCelebrityFriendsExpectation) Then(sa1 []string, err error) *DurableRepoMock {
	e.results = &DurableRepoMockGetCelebrityFriendsResults{sa1, err}
	return e.mock
}

// GetCelebrityFriends implements feed.durableRepo
func (mmGetCelebrityFriends *DurableRepoMock) GetCelebrityFriends(ctx context.Context, username string) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmGetCelebrityFriends.beforeGetCelebrityFriendsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCelebrityFriends.afterGetCelebrityFriendsCounter, 1)

	if mmGetCelebrityFriends.inspectFuncGetCelebrityFriends != nil {
		mmGetCelebrityFriends.inspectFuncGetCelebrityFriends(ctx, username)
	}

	mm_params := &DurableRepoMockGetCelebrityFriendsParams{ctx, username}

	// Record call args
	mmGetCelebrityFriends.GetCelebrityFriendsMock.mutex.Lock()
	mmGetCelebrityFriends.GetCelebrityFriendsMock.callArgs = append(mmGetCelebrityFriends.GetCelebrityFriendsMock.callArgs, mm_params)
	mmGetCelebrityFriends.GetCelebrityFriendsMock.mutex.Unlock()

	for _, e := range mmGetCelebrityFriends.GetCelebrityFriendsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmGetCelebrityFriends.GetCelebrityFriendsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCelebrityFriends.GetCelebrityFriendsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCelebrityFriends.GetCelebrityFriendsMock.defaultExpectation.params
		mm_got := DurableRepoMockGetCelebrityFriendsParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCelebrityFriends.t.Errorf("DurableRepoMock.GetCelebrityFriends got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCelebrityFriends.GetCelebrityFriendsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCelebrityFriends.t.Fatal("No results are set for the DurableRepoMock.GetCelebrityFriends")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmGetCelebrityFriends.funcGetCelebrityFriends != nil {
		return mmGetCelebrityFriends.funcGetCelebrityFriends(ctx, username)
	}
	mmGetCelebrityFriends.t.Fatalf("Unexpected call to DurableRepoMock.GetCelebrityFriends. %v %v", ctx, username)
	return
}

// GetCelebrityFriendsAfterCounter returns a count of finished DurableRepoMock.GetCelebrityFriends invocations
func (mmGetCelebrityFriends *DurableRepoMock) GetCelebrityFriendsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCelebrityFriends.afterGetCelebrityFriendsCounter)
}

// GetCelebrityFriendsBeforeCounter returns a count of DurableRepoMock.GetCelebrityFriends invocations
func (mmGetCelebrityFriends *DurableRepoMock) GetCelebrityFriendsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCelebrityFriends.beforeGetCelebrityFriendsCounter)
}

// Calls returns a list of arguments used in each call to DurableRepoMock.GetCelebrityFriends.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCelebrityFriends *mDurableRepoMockGetCelebrityFriends) Calls() []*DurableRepoMockGetCelebrityFriendsParams {
	mmGetCelebrityFriends.mutex.RLock()

	argCopy := make([]*DurableRepoMockGetCelebrityFriendsParams, len(mmGetCelebrityFriends.callArgs))
	copy(argCopy, mmGetCelebrityFriends.callArgs)

	mmGetCelebrityFriends.mutex.RUnlock()

	return argCopy
}

// MinimockGetCelebrityFriendsDone returns true if the count of the GetCelebrityFriends invocations corresponds
// the number of defined expectations
func (m *DurableRepoMock) MinimockGetCelebrityFriendsDone() bool {
	for _, e := range m.GetCelebrityFriendsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCelebrityFriendsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCelebrityFriendsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCelebrityFriends != nil && mm_atomic.LoadUint64(&m.afterGetCelebrityFriendsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCelebrityFriendsInspect logs each unmet expectation
func (m *DurableRepoMock) MinimockGetCelebrityFriendsInspect() {
	for _, e := range m.GetCelebrityFriendsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DurableRepoMock.GetCelebrityFriends with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCelebrityFriendsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCelebrityFriendsCounter) < 1 {
		if m.GetCelebrityFriendsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DurableRepoMock.GetCelebrityFriends")
		} else {
			m.t.Errorf("Expected call to DurableRepoMock.GetCelebrityFriends with params: %#v", *m.GetCelebrityFriendsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCelebrityFriends != nil && mm_atomic.LoadUint64(&m.afterGetCelebrityFriendsCounter) < 1 {
		m.t.Error("Expected call to DurableRepoMock.GetCelebrityFriends")
	}
}

type mDurableRepoMockGetPostFeed struct {
	mock               *DurableRepoMock
	defaultExpectation *DurableRepoMockGetPostFeedExpectation
	expectations       []*DurableRepoMockGetPostFeedExpectation

	callArgs []*DurableRepoMockGetPostFeedParams
	mutex    sync.RWMutex
}

// DurableRepoMockGetPostFeedExpectation specifies expectation struct of the durableRepo.GetPostFeed
type DurableRepoMockGetPostFeedExpectation struct {
	mock    *DurableRepoMock
	params  *DurableRepoMockGetPostFeedParams
	results *DurableRepoMockGetPostFeedResults
	Counter uint64
}

// DurableRepoMockGetPostFeedParams contains parameters of the durableRepo.GetPostFeed
type DurableRepoMockGetPostFeedParams struct {
	ctx      context.Context
	username string
	limit    uint
}

// DurableRepoMockGetPostFeedResults contains results of the durableRepo.GetPostFeed
type DurableRepoMockGetPostFeedResults struct {
	pa1 []dto.PostShortInfo
	err error
}

// Expect sets up expected params for durableRepo.GetPostFeed
func (mmGetPostFeed *mDurableRepoMockGetPostFeed) Expect(ctx context.Context, username string, limit uint) *mDurableRepoMockGetPostFeed {
	if mmGetPostFeed.mock.funcGetPostFeed != nil {
		mmGetPostFeed.mock.t.Fatalf("DurableRepoMock.GetPostFeed mock is already set by Set")
	}

	if mmGetPostFeed.defaultExpectation == nil {
		mmGetPostFeed.defaultExpectation = &DurableRepoMockGetPostFeedExpectation{}
	}

	mmGetPostFeed.defaultExpectation.params = &DurableRepoMockGetPostFeedParams{ctx, username, limit}
	for _, e := range mmGetPostFeed.expectations {
		if minimock.Equal(e.params, mmGetPostFeed.defaultExpectation.params) {
			mmGetPostFeed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPostFeed.defaultExpectation.params)
		}
	}

	return mmGetPostFeed
}

// Inspect accepts an inspector function that has same arguments as the durableRepo.GetPostFeed
func (mmGetPostFeed *mDurableRepoMockGetPostFeed) Inspect(f func(ctx context.Context, username string, limit uint)) *mDurableRepoMockGetPostFeed {
	if mmGetPostFeed.mock.inspectFuncGetPostFeed != nil {
		mmGetPostFeed.mock.t.Fatalf("Inspect function is already set for DurableRepoMock.GetPostFeed")
	}

	mmGetPostFeed.mock.inspectFuncGetPostFeed = f

	return mmGetPostFeed
}

// Return sets up results that will be returned by durableRepo.GetPostFeed
func (mmGetPostFeed *mDurableRepoMockGetPostFeed) Return(pa1 []dto.PostShortInfo, err error) *DurableRepoMock {
	if mmGetPostFeed.mock.funcGetPostFeed != nil {
		mmGetPostFeed.mock.t.Fatalf("DurableRepoMock.GetPostFeed mock is already set by Set")
	}

	if mmGetPostFeed.defaultExpectation == nil {
		mmGetPostFeed.defaultExpectation = &DurableRepoMockGetPostFeedExpectation{mock: mmGetPostFeed.mock}
	}
	mmGetPostFeed.defaultExpectation.results = &DurableRepoMockGetPostFeedResults{pa1, err}
	return mmGetPostFeed.mock
}

//Set uses given function f to mock the durableRepo.GetPostFeed method
func (mmGetPostFeed *mDurableRepoMockGetPostFeed) Set(f func(ctx context.Context, username string, limit uint) (pa1 []dto.PostShortInfo, err error)) *DurableRepoMock {
	if mmGetPostFeed.defaultExpectation != nil {
		mmGetPostFeed.mock.t.Fatalf("Default expectation is already set for the durableRepo.GetPostFeed method")
	}

	if len(mmGetPostFeed.expectations) > 0 {
		mmGetPostFeed.mock.t.Fatalf("Some expectations are already set for the durableRepo.GetPostFeed method")
	}

	mmGetPostFeed.mock.funcGetPostFeed = f
	return mmGetPostFeed.mock
}

// When sets expectation for the durableRepo.GetPostFeed which will trigger the result defined by the following
// Then helper
func (mmGetPostFeed *mDurableRepoMockGetPostFeed) When(ctx context.Context, username string, limit uint) *DurableRepoMockGetPostFeedExpectation {
	if mmGetPostFeed.mock.funcGetPostFeed != nil {
		mmGetPostFeed.mock.t.Fatalf("DurableRepoMock.GetPostFeed mock is already set by Set")
	}

	expectation := &DurableRepoMockGetPostFeedExpectation{
		mock:   mmGetPostFeed.mock,
		params: &DurableRepoMockGetPostFeedParams{ctx, username, limit},
	}
	mmGetPostFeed.expectations = append(mmGetPostFeed.expectations, expectation)
	return expectation
}

// Then sets up durableRepo.GetPostFeed return parameters for the expectation previously defined by the When method
func (e *DurableRepoMockGetPostFeedExpectation) Then(pa1 []dto.PostShortInfo, err error) *DurableRepoMock {
	e.results = &DurableRepoMockGetPostFeedResults{pa1, err}
	return e.mock
}

// GetPostFeed implements feed.durableRepo
func (mmGetPostFeed *DurableRepoMock) GetPostFeed(ctx context.Context, username string, limit uint) (pa1 []dto.PostShortInfo, err error) {
	mm_atomic.AddUint64(&mmGetPostFeed.beforeGetPostFeedCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPostFeed.afterGetPostFeedCounter, 1)

	if mmGetPostFeed.inspectFuncGetPostFeed != nil {
		mmGetPostFeed.inspectFuncGetPostFeed(ctx, username, limit)
	}

	mm_params := &DurableRepoMockGetPostFeedParams{ctx, username, limit}

	// Record call args
	mmGetPostFeed.GetPostFeedMock.mutex.Lock()
	mmGetPostFeed.GetPostFeedMock.callArgs = append(mmGetPostFeed.GetPostFeedMock.callArgs, mm_params)
	mmGetPostFeed.GetPostFeedMock.mutex.Unlock()

	for _, e := range mmGetPostFeed.GetPostFeedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetPostFeed.GetPostFeedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPostFeed.GetPostFeedMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPostFeed.GetPostFeedMock.defaultExpectation.params
		mm_got := DurableRepoMockGetPostFeedParams{ctx, username, limit}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPostFeed.t.Errorf("DurableRepoMock.GetPostFeed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPostFeed.GetPostFeedMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPostFeed.t.Fatal("No results are set for the DurableRepoMock.GetPostFeed")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetPostFeed.funcGetPostFeed != nil {
		return mmGetPostFeed.funcGetPostFeed(ctx, username, limit)
	}
	mmGetPostFeed.t.Fatalf("Unexpected call to DurableRepoMock.GetPostFeed. %v %v %v", ctx, username, limit)
	return
}

// GetPostFeedAfterCounter returns a count of finished DurableRepoMock.GetPostFeed invocations
func (mmGetPostFeed *DurableRepoMock) GetPostFeedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostFeed.afterGetPostFeedCounter)
}

// GetPostFeedBeforeCounter returns a count of DurableRepoMock.GetPostFeed invocations
func (mmGetPostFeed *DurableRepoMock) GetPostFeedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostFeed.beforeGetPostFeedCounter)
}

// Calls returns a list of arguments used in each call to DurableRepoMock.GetPostFeed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPostFeed *mDurableRepoMockGetPostFeed) Calls() []*DurableRepoMockGetPostFeedParams {
	mmGetPostFeed.mutex.RLock()

	argCopy := make([]*DurableRepoMockGetPostFeedParams, len(mmGetPostFeed.callArgs))
	copy(argCopy, mmGetPostFeed.callArgs)

	mmGetPostFeed.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostFeedDone returns true if the count of the GetPostFeed invocations corresponds
// the number of defined expectations
func (m *DurableRepoMock) MinimockGetPostFeedDone() bool {
	for _, e := range m.GetPostFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPostFeedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPostFeed != nil && mm_atomic.LoadUint64(&m.afterGetPostFeedCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPostFeedInspect logs each unmet expectation
func (m *DurableRepoMock) MinimockGetPostFeedInspect() {
	for _, e := range m.GetPostFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DurableRepoMock.GetPostFeed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPostFeedCounter) < 1 {
		if m.GetPostFeedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DurableRepoMock.GetPostFeed")
		} else {
			m.t.Errorf("Expected call to DurableRepoMock.GetPostFeed with params: %#v", *m.GetPostFeedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPostFeed != nil && mm_atomic.LoadUint64(&m.afterGetPostFeedCounter) < 1 {
		m.t.Error("Expected call to DurableRepoMock.GetPostFeed")
	}
}

type mDurableRepoMockGetPostsByFilters struct {
	mock               *DurableRepoMock
	defaultExpectation *DurableRepoMockGetPostsByFiltersExpectation
	expectations       []*DurableRepoMockGetPostsByFiltersExpectation

	callArgs []*DurableRepoMockGetPostsByFiltersParams
	mutex    sync.RWMutex
}

// DurableRepoMockGetPostsByFiltersExpectation specifies expectation struct of the durableRepo.GetPostsByFilters
type DurableRepoMockGetPostsByFiltersExpectation struct {
	mock    *DurableRepoMock
	params  *DurableRepoMockGetPostsByFiltersParams
	results *DurableRepoMockGetPostsByFiltersResults
	Counter uint64
}

// DurableRepoMockGetPostsByFiltersParams contains parameters of the durableRepo.GetPostsByFilters
type DurableRepoMockGetPostsByFiltersParams struct {
	ctx     context.Context
	filters dto.PostFilters
	limit   uint
	offset  uint
}

// DurableRepoMockGetPostsByFiltersResults contains results of the durableRepo.GetPostsByFilters
type DurableRepoMockGetPostsByFiltersResults struct {
	pa1 []dto.PostShortInfo
	err error
}

// Expect sets up expected params for durableRepo.GetPostsByFilters
func (mmGetPostsByFilters *mDurableRepoMockGetPostsByFilters) Expect(ctx context.Context, filters dto.PostFilters, limit uint, offset uint) *mDurableRepoMockGetPostsByFilters {
	if mmGetPostsByFilters.mock.funcGetPostsByFilters != nil {
		mmGetPostsByFilters.mock.t.Fatalf("DurableRepoMock.GetPostsByFilters mock is already set by Set")
	}

	if mmGetPostsByFilters.defaultExpectation == nil {
		mmGetPostsByFilters.defaultExpectation = &DurableRepoMockGetPostsByFiltersExpectation{}
	}

	mmGetPostsByFilters.defaultExpectation.params = &DurableRepoMockGetPostsByFiltersParams{ctx, filters, limit, offset}
	for _, e := range mmGetPostsByFilters.expectations {
		if minimock.Equal(e.params, mmGetPostsByFilters.defaultExpectation.params) {
			mmGetPostsByFilters.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPostsByFilters.defaultExpectation.params)
		}
	}

	return mmGetPostsByFilters
}

// Inspect accepts an inspector function that has same arguments as the durableRepo.GetPostsByFilters
func (mmGetPostsByFilters *mDurableRepoMockGetPostsByFilters) Inspect(f func(ctx context.Context, filters dto.PostFilters, limit uint, offset uint)) *mDurableRepoMockGetPostsByFilters {
	if mmGetPostsByFilters.mock.inspectFuncGetPostsByFilters != nil {
		mmGetPostsByFilters.mock.t.Fatalf("Inspect function is already set for DurableRepoMock.GetPostsByFilters")
	}

	mmGetPostsByFilters.mock.inspectFuncGetPostsByFilters = f

	return mmGetPostsByFilters
}

// Return sets up results that will be returned by durableRepo.GetPostsByFilters
func (mmGetPostsByFilters *mDurableRepoMockGetPostsByFilters) Return(pa1 []dto.PostShortInfo, err error) *DurableRepoMock {
	if mmGetPostsByFilters.mock.funcGetPostsByFilters != nil {
		mmGetPostsByFilters.mock.t.Fatalf("DurableRepoMock.GetPostsByFilters mock is already set by Set")
	}

	if mmGetPostsByFilters.defaultExpectation == nil {
		mmGetPostsByFilters.defaultExpectation = &DurableRepoMockGetPostsByFiltersExpectation{mock: mmGetPostsByFilters.mock}
	}
	mmGetPostsByFilters.defaultExpectation.results = &DurableRepoMockGetPostsByFiltersResults{pa1, err}
	return mmGetPostsByFilters.mock
}

//Set uses given function f to mock the durableRepo.GetPostsByFilters method
func (mmGetPostsByFilters *mDurableRepoMockGetPostsByFilters) Set(f func(ctx context.Context, filters dto.PostFilters, limit uint, offset uint) (pa1 []dto.PostShortInfo, err error)) *DurableRepoMock {
	if mmGetPostsByFilters.defaultExpectation != nil {
		mmGetPostsByFilters.mock.t.Fatalf("Default expectation is already set for the durableRepo.GetPostsByFilters method")
	}

	if len(mmGetPostsByFilters.expectations) > 0 {
		mmGetPostsByFilters.mock.t.Fatalf("Some expectations are already set for the durableRepo.GetPostsByFilters method")
	}

	mmGetPostsByFilters.mock.funcGetPostsByFilters = f
	return mmGetPostsByFilters.mock
}

// When sets expectation for the durableRepo.GetPostsByFilters which will trigger the result defined by the following
// Then helper
func (mmGetPostsByFilters *mDurableRepoMockGetPostsByFilters) When(ctx context.Context, filters dto.PostFilters, limit uint, offset uint) *DurableRepoMockGetPostsByFiltersExpectation {
	if mmGetPostsByFilters.mock.funcGetPostsByFilters != nil {
		mmGetPostsByFilters.mock.t.Fatalf("DurableRepoMock.GetPostsByFilters mock is already set by Set")
	}

	expectation := &DurableRepoMockGetPostsByFiltersExpectation{
		mock:   mmGetPostsByFilters.mock,
		params: &DurableRepoMockGetPostsByFiltersParams{ctx, filters, limit, offset},
	}
	mmGetPostsByFilters.expectations = append(mmGetPostsByFilters.expectations, expectation)
	return expectation
}

// Then sets up durableRepo.GetPostsByFilters return parameters for the expectation previously defined by the When method
func (e *DurableRepoMockGetPostsByFiltersExpectation) Then(pa1 []dto.PostShortInfo, err error) *DurableRepoMock {
	e.results = &DurableRepoMockGetPostsByFiltersResults{pa1, err}
	return e.mock
}

// GetPostsByFilters implements feed.durableRepo
func (mmGetPostsByFilters *DurableRepoMock) GetPostsByFilters(ctx context.Context, filters dto.PostFilters, limit uint, offset uint) (pa1 []dto.PostShortInfo, err error) {
	mm_atomic.AddUint64(&mmGetPostsByFilters.beforeGetPostsByFiltersCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPostsByFilters.afterGetPostsByFiltersCounter, 1)

	if mmGetPostsByFilters.inspectFuncGetPostsByFilters != nil {
		mmGetPostsByFilters.inspectFuncGetPostsByFilters(ctx, filters, limit, offset)
	}

	mm_params := &DurableRepoMockGetPostsByFiltersParams{ctx, filters, limit, offset}

	// Record call args
	mmGetPostsByFilters.GetPostsByFiltersMock.mutex.Lock()
	mmGetPostsByFilters.GetPostsByFiltersMock.callArgs = append(mmGetPostsByFilters.GetPostsByFiltersMock.callArgs, mm_params)
	mmGetPostsByFilters.GetPostsByFiltersMock.mutex.Unlock()

	for _, e := range mmGetPostsByFilters.GetPostsByFiltersMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetPostsByFilters.GetPostsByFiltersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPostsByFilters.GetPostsByFiltersMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPostsByFilters.GetPostsByFiltersMock.defaultExpectation.params
		mm_got := DurableRepoMockGetPostsByFiltersParams{ctx, filters, limit, offset}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPostsByFilters.t.Errorf("DurableRepoMock.GetPostsByFilters got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPostsByFilters.GetPostsByFiltersMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPostsByFilters.t.Fatal("No results are set for the DurableRepoMock.GetPostsByFilters")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetPostsByFilters.funcGetPostsByFilters != nil {
		return mmGetPostsByFilters.funcGetPostsByFilters(ctx, filters, limit, offset)
	}
	mmGetPostsByFilters.t.Fatalf("Unexpected call to DurableRepoMock.GetPostsByFilters. %v %v %v %v", ctx, filters, limit, offset)
	return
}

// GetPostsByFiltersAfterCounter returns a count of finished DurableRepoMock.GetPostsByFilters invocations
func (mmGetPostsByFilters *DurableRepoMock) GetPostsByFiltersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostsByFilters.afterGetPostsByFiltersCounter)
}

// GetPostsByFiltersBeforeCounter returns a count of DurableRepoMock.GetPostsByFilters invocations
func (mmGetPostsByFilters *DurableRepoMock) GetPostsByFiltersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostsByFilters.beforeGetPostsByFiltersCounter)
}

// Calls returns a list of arguments used in each call to DurableRepoMock.GetPostsByFilters.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPostsByFilters *mDurableRepoMockGetPostsByFilters) Calls() []*DurableRepoMockGetPostsByFiltersParams {
	mmGetPostsByFilters.mutex.RLock()

	argCopy := make([]*DurableRepoMockGetPostsByFiltersParams, len(mmGetPostsByFilters.callArgs))
	copy(argCopy, mmGetPostsByFilters.callArgs)

	mmGetPostsByFilters.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostsByFiltersDone returns true if the count of the GetPostsByFilters invocations corresponds
// the number of defined expectations
func (m *DurableRepoMock) MinimockGetPostsByFiltersDone() bool {
	for _, e := range m.GetPostsByFiltersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostsByFiltersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPostsByFiltersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPostsByFilters != nil && mm_atomic.LoadUint64(&m.afterGetPostsByFiltersCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPostsByFiltersInspect logs each unmet expectation
func (m *DurableRepoMock) MinimockGetPostsByFiltersInspect() {
	for _, e := range m.GetPostsByFiltersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to DurableRepoMock.GetPostsByFilters with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostsByFiltersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPostsByFiltersCounter) < 1 {
		if m.GetPostsByFiltersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to DurableRepoMock.GetPostsByFilters")
		} else {
			m.t.Errorf("Expected call to DurableRepoMock.GetPostsByFilters with params: %#v", *m.GetPostsByFiltersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPostsByFilters != nil && mm_atomic.LoadUint64(&m.afterGetPostsByFiltersCounter) < 1 {
		m.t.Error("Expected call to DurableRepoMock.GetPostsByFilters")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *DurableRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetCelebrityFriendsInspect()

		m.MinimockGetPostFeedInspect()

		m.MinimockGetPostsByFiltersInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *DurableRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *DurableRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCelebrityFriendsDone() &&
		m.MinimockGetPostFeedDone() &&
		m.MinimockGetPostsByFiltersDone()
}
