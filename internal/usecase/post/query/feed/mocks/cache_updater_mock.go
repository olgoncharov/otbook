package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/olgoncharov/otbook/internal/usecase/post/query/feed.cacheUpdater -o ./internal/usecase/post/query/feed/mocks/cache_updater_mock.go -n CacheUpdaterMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CacheUpdaterMock implements feed.cacheUpdater
type CacheUpdaterMock struct {
	t minimock.Tester

	funcWarmupCelebrityFriendsList          func(ctx context.Context, username string)
	inspectFuncWarmupCelebrityFriendsList   func(ctx context.Context, username string)
	afterWarmupCelebrityFriendsListCounter  uint64
	beforeWarmupCelebrityFriendsListCounter uint64
	WarmupCelebrityFriendsListMock          mCacheUpdaterMockWarmupCelebrityFriendsList

	funcWarmupFeed          func(ctx context.Context, username string)
	inspectFuncWarmupFeed   func(ctx context.Context, username string)
	afterWarmupFeedCounter  uint64
	beforeWarmupFeedCounter uint64
	WarmupFeedMock          mCacheUpdaterMockWarmupFeed
}

// NewCacheUpdaterMock returns a mock for feed.cacheUpdater
func NewCacheUpdaterMock(t minimock.Tester) *CacheUpdaterMock {
	m := &CacheUpdaterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.WarmupCelebrityFriendsListMock = mCacheUpdaterMockWarmupCelebrityFriendsList{mock: m}
	m.WarmupCelebrityFriendsListMock.callArgs = []*CacheUpdaterMockWarmupCelebrityFriendsListParams{}

	m.WarmupFeedMock = mCacheUpdaterMockWarmupFeed{mock: m}
	m.WarmupFeedMock.callArgs = []*CacheUpdaterMockWarmupFeedParams{}

	return m
}

type mCacheUpdaterMockWarmupCelebrityFriendsList struct {
	mock               *CacheUpdaterMock
	defaultExpectation *CacheUpdaterMockWarmupCelebrityFriendsListExpectation
	expectations       []*CacheUpdaterMockWarmupCelebrityFriendsListExpectation

	callArgs []*CacheUpdaterMockWarmupCelebrityFriendsListParams
	mutex    sync.RWMutex
}

// CacheUpdaterMockWarmupCelebrityFriendsListExpectation specifies expectation struct of the cacheUpdater.WarmupCelebrityFriendsList
type CacheUpdaterMockWarmupCelebrityFriendsListExpectation struct {
	mock   *CacheUpdaterMock
	params *CacheUpdaterMockWarmupCelebrityFriendsListParams

	Counter uint64
}

// CacheUpdaterMockWarmupCelebrityFriendsListParams contains parameters of the cacheUpdater.WarmupCelebrityFriendsList
type CacheUpdaterMockWarmupCelebrityFriendsListParams struct {
	ctx      context.Context
	username string
}

// Expect sets up expected params for cacheUpdater.WarmupCelebrityFriendsList
func (mmWarmupCelebrityFriendsList *mCacheUpdaterMockWarmupCelebrityFriendsList) Expect(ctx context.Context, username string) *mCacheUpdaterMockWarmupCelebrityFriendsList {
	if mmWarmupCelebrityFriendsList.mock.funcWarmupCelebrityFriendsList != nil {
		mmWarmupCelebrityFriendsList.mock.t.Fatalf("CacheUpdaterMock.WarmupCelebrityFriendsList mock is already set by Set")
	}

	if mmWarmupCelebrityFriendsList.defaultExpectation == nil {
		mmWarmupCelebrityFriendsList.defaultExpectation = &CacheUpdaterMockWarmupCelebrityFriendsListExpectation{}
	}

	mmWarmupCelebrityFriendsList.defaultExpectation.params = &CacheUpdaterMockWarmupCelebrityFriendsListParams{ctx, username}
	for _, e := range mmWarmupCelebrityFriendsList.expectations {
		if minimock.Equal(e.params, mmWarmupCelebrityFriendsList.defaultExpectation.params) {
			mmWarmupCelebrityFriendsList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarmupCelebrityFriendsList.defaultExpectation.params)
		}
	}

	return mmWarmupCelebrityFriendsList
}

// Inspect accepts an inspector function that has same arguments as the cacheUpdater.WarmupCelebrityFriendsList
func (mmWarmupCelebrityFriendsList *mCacheUpdaterMockWarmupCelebrityFriendsList) Inspect(f func(ctx context.Context, username string)) *mCacheUpdaterMockWarmupCelebrityFriendsList {
	if mmWarmupCelebrityFriendsList.mock.inspectFuncWarmupCelebrityFriendsList != nil {
		mmWarmupCelebrityFriendsList.mock.t.Fatalf("Inspect function is already set for CacheUpdaterMock.WarmupCelebrityFriendsList")
	}

	mmWarmupCelebrityFriendsList.mock.inspectFuncWarmupCelebrityFriendsList = f

	return mmWarmupCelebrityFriendsList
}

// Return sets up results that will be returned by cacheUpdater.WarmupCelebrityFriendsList
func (mmWarmupCelebrityFriendsList *mCacheUpdaterMockWarmupCelebrityFriendsList) Return() *CacheUpdaterMock {
	if mmWarmupCelebrityFriendsList.mock.funcWarmupCelebrityFriendsList != nil {
		mmWarmupCelebrityFriendsList.mock.t.Fatalf("CacheUpdaterMock.WarmupCelebrityFriendsList mock is already set by Set")
	}

	if mmWarmupCelebrityFriendsList.defaultExpectation == nil {
		mmWarmupCelebrityFriendsList.defaultExpectation = &CacheUpdaterMockWarmupCelebrityFriendsListExpectation{mock: mmWarmupCelebrityFriendsList.mock}
	}

	return mmWarmupCelebrityFriendsList.mock
}

//Set uses given function f to mock the cacheUpdater.WarmupCelebrityFriendsList method
func (mmWarmupCelebrityFriendsList *mCacheUpdaterMockWarmupCelebrityFriendsList) Set(f func(ctx context.Context, username string)) *CacheUpdaterMock {
	if mmWarmupCelebrityFriendsList.defaultExpectation != nil {
		mmWarmupCelebrityFriendsList.mock.t.Fatalf("Default expectation is already set for the cacheUpdater.WarmupCelebrityFriendsList method")
	}

	if len(mmWarmupCelebrityFriendsList.expectations) > 0 {
		mmWarmupCelebrityFriendsList.mock.t.Fatalf("Some expectations are already set for the cacheUpdater.WarmupCelebrityFriendsList method")
	}

	mmWarmupCelebrityFriendsList.mock.funcWarmupCelebrityFriendsList = f
	return mmWarmupCelebrityFriendsList.mock
}

// WarmupCelebrityFriendsList implements feed.cacheUpdater
func (mmWarmupCelebrityFriendsList *CacheUpdaterMock) WarmupCelebrityFriendsList(ctx context.Context, username string) {
	mm_atomic.AddUint64(&mmWarmupCelebrityFriendsList.beforeWarmupCelebrityFriendsListCounter, 1)
	defer mm_atomic.AddUint64(&mmWarmupCelebrityFriendsList.afterWarmupCelebrityFriendsListCounter, 1)

	if mmWarmupCelebrityFriendsList.inspectFuncWarmupCelebrityFriendsList != nil {
		mmWarmupCelebrityFriendsList.inspectFuncWarmupCelebrityFriendsList(ctx, username)
	}

	mm_params := &CacheUpdaterMockWarmupCelebrityFriendsListParams{ctx, username}

	// Record call args
	mmWarmupCelebrityFriendsList.WarmupCelebrityFriendsListMock.mutex.Lock()
	mmWarmupCelebrityFriendsList.WarmupCelebrityFriendsListMock.callArgs = append(mmWarmupCelebrityFriendsList.WarmupCelebrityFriendsListMock.callArgs, mm_params)
	mmWarmupCelebrityFriendsList.WarmupCelebrityFriendsListMock.mutex.Unlock()

	for _, e := range mmWarmupCelebrityFriendsList.WarmupCelebrityFriendsListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarmupCelebrityFriendsList.WarmupCelebrityFriendsListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarmupCelebrityFriendsList.WarmupCelebrityFriendsListMock.defaultExpectation.Counter, 1)
		mm_want := mmWarmupCelebrityFriendsList.WarmupCelebrityFriendsListMock.defaultExpectation.params
		mm_got := CacheUpdaterMockWarmupCelebrityFriendsListParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarmupCelebrityFriendsList.t.Errorf("CacheUpdaterMock.WarmupCelebrityFriendsList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarmupCelebrityFriendsList.funcWarmupCelebrityFriendsList != nil {
		mmWarmupCelebrityFriendsList.funcWarmupCelebrityFriendsList(ctx, username)
		return
	}
	mmWarmupCelebrityFriendsList.t.Fatalf("Unexpected call to CacheUpdaterMock.WarmupCelebrityFriendsList. %v %v", ctx, username)

}

// WarmupCelebrityFriendsListAfterCounter returns a count of finished CacheUpdaterMock.WarmupCelebrityFriendsList invocations
func (mmWarmupCelebrityFriendsList *CacheUpdaterMock) WarmupCelebrityFriendsListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarmupCelebrityFriendsList.afterWarmupCelebrityFriendsListCounter)
}

// WarmupCelebrityFriendsListBeforeCounter returns a count of CacheUpdaterMock.WarmupCelebrityFriendsList invocations
func (mmWarmupCelebrityFriendsList *CacheUpdaterMock) WarmupCelebrityFriendsListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarmupCelebrityFriendsList.beforeWarmupCelebrityFriendsListCounter)
}

// Calls returns a list of arguments used in each call to CacheUpdaterMock.WarmupCelebrityFriendsList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarmupCelebrityFriendsList *mCacheUpdaterMockWarmupCelebrityFriendsList) Calls() []*CacheUpdaterMockWarmupCelebrityFriendsListParams {
	mmWarmupCelebrityFriendsList.mutex.RLock()

	argCopy := make([]*CacheUpdaterMockWarmupCelebrityFriendsListParams, len(mmWarmupCelebrityFriendsList.callArgs))
	copy(argCopy, mmWarmupCelebrityFriendsList.callArgs)

	mmWarmupCelebrityFriendsList.mutex.RUnlock()

	return argCopy
}

// MinimockWarmupCelebrityFriendsListDone returns true if the count of the WarmupCelebrityFriendsList invocations corresponds
// the number of defined expectations
func (m *CacheUpdaterMock) MinimockWarmupCelebrityFriendsListDone() bool {
	for _, e := range m.WarmupCelebrityFriendsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarmupCelebrityFriendsListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarmupCelebrityFriendsListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarmupCelebrityFriendsList != nil && mm_atomic.LoadUint64(&m.afterWarmupCelebrityFriendsListCounter) < 1 {
		return false
	}
	return true
}

// MinimockWarmupCelebrityFriendsListInspect logs each unmet expectation
func (m *CacheUpdaterMock) MinimockWarmupCelebrityFriendsListInspect() {
	for _, e := range m.WarmupCelebrityFriendsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheUpdaterMock.WarmupCelebrityFriendsList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarmupCelebrityFriendsListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarmupCelebrityFriendsListCounter) < 1 {
		if m.WarmupCelebrityFriendsListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheUpdaterMock.WarmupCelebrityFriendsList")
		} else {
			m.t.Errorf("Expected call to CacheUpdaterMock.WarmupCelebrityFriendsList with params: %#v", *m.WarmupCelebrityFriendsListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarmupCelebrityFriendsList != nil && mm_atomic.LoadUint64(&m.afterWarmupCelebrityFriendsListCounter) < 1 {
		m.t.Error("Expected call to CacheUpdaterMock.WarmupCelebrityFriendsList")
	}
}

type mCacheUpdaterMockWarmupFeed struct {
	mock               *CacheUpdaterMock
	defaultExpectation *CacheUpdaterMockWarmupFeedExpectation
	expectations       []*CacheUpdaterMockWarmupFeedExpectation

	callArgs []*CacheUpdaterMockWarmupFeedParams
	mutex    sync.RWMutex
}

// CacheUpdaterMockWarmupFeedExpectation specifies expectation struct of the cacheUpdater.WarmupFeed
type CacheUpdaterMockWarmupFeedExpectation struct {
	mock   *CacheUpdaterMock
	params *CacheUpdaterMockWarmupFeedParams

	Counter uint64
}

// CacheUpdaterMockWarmupFeedParams contains parameters of the cacheUpdater.WarmupFeed
type CacheUpdaterMockWarmupFeedParams struct {
	ctx      context.Context
	username string
}

// Expect sets up expected params for cacheUpdater.WarmupFeed
func (mmWarmupFeed *mCacheUpdaterMockWarmupFeed) Expect(ctx context.Context, username string) *mCacheUpdaterMockWarmupFeed {
	if mmWarmupFeed.mock.funcWarmupFeed != nil {
		mmWarmupFeed.mock.t.Fatalf("CacheUpdaterMock.WarmupFeed mock is already set by Set")
	}

	if mmWarmupFeed.defaultExpectation == nil {
		mmWarmupFeed.defaultExpectation = &CacheUpdaterMockWarmupFeedExpectation{}
	}

	mmWarmupFeed.defaultExpectation.params = &CacheUpdaterMockWarmupFeedParams{ctx, username}
	for _, e := range mmWarmupFeed.expectations {
		if minimock.Equal(e.params, mmWarmupFeed.defaultExpectation.params) {
			mmWarmupFeed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWarmupFeed.defaultExpectation.params)
		}
	}

	return mmWarmupFeed
}

// Inspect accepts an inspector function that has same arguments as the cacheUpdater.WarmupFeed
func (mmWarmupFeed *mCacheUpdaterMockWarmupFeed) Inspect(f func(ctx context.Context, username string)) *mCacheUpdaterMockWarmupFeed {
	if mmWarmupFeed.mock.inspectFuncWarmupFeed != nil {
		mmWarmupFeed.mock.t.Fatalf("Inspect function is already set for CacheUpdaterMock.WarmupFeed")
	}

	mmWarmupFeed.mock.inspectFuncWarmupFeed = f

	return mmWarmupFeed
}

// Return sets up results that will be returned by cacheUpdater.WarmupFeed
func (mmWarmupFeed *mCacheUpdaterMockWarmupFeed) Return() *CacheUpdaterMock {
	if mmWarmupFeed.mock.funcWarmupFeed != nil {
		mmWarmupFeed.mock.t.Fatalf("CacheUpdaterMock.WarmupFeed mock is already set by Set")
	}

	if mmWarmupFeed.defaultExpectation == nil {
		mmWarmupFeed.defaultExpectation = &CacheUpdaterMockWarmupFeedExpectation{mock: mmWarmupFeed.mock}
	}

	return mmWarmupFeed.mock
}

//Set uses given function f to mock the cacheUpdater.WarmupFeed method
func (mmWarmupFeed *mCacheUpdaterMockWarmupFeed) Set(f func(ctx context.Context, username string)) *CacheUpdaterMock {
	if mmWarmupFeed.defaultExpectation != nil {
		mmWarmupFeed.mock.t.Fatalf("Default expectation is already set for the cacheUpdater.WarmupFeed method")
	}

	if len(mmWarmupFeed.expectations) > 0 {
		mmWarmupFeed.mock.t.Fatalf("Some expectations are already set for the cacheUpdater.WarmupFeed method")
	}

	mmWarmupFeed.mock.funcWarmupFeed = f
	return mmWarmupFeed.mock
}

// WarmupFeed implements feed.cacheUpdater
func (mmWarmupFeed *CacheUpdaterMock) WarmupFeed(ctx context.Context, username string) {
	mm_atomic.AddUint64(&mmWarmupFeed.beforeWarmupFeedCounter, 1)
	defer mm_atomic.AddUint64(&mmWarmupFeed.afterWarmupFeedCounter, 1)

	if mmWarmupFeed.inspectFuncWarmupFeed != nil {
		mmWarmupFeed.inspectFuncWarmupFeed(ctx, username)
	}

	mm_params := &CacheUpdaterMockWarmupFeedParams{ctx, username}

	// Record call args
	mmWarmupFeed.WarmupFeedMock.mutex.Lock()
	mmWarmupFeed.WarmupFeedMock.callArgs = append(mmWarmupFeed.WarmupFeedMock.callArgs, mm_params)
	mmWarmupFeed.WarmupFeedMock.mutex.Unlock()

	for _, e := range mmWarmupFeed.WarmupFeedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmWarmupFeed.WarmupFeedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWarmupFeed.WarmupFeedMock.defaultExpectation.Counter, 1)
		mm_want := mmWarmupFeed.WarmupFeedMock.defaultExpectation.params
		mm_got := CacheUpdaterMockWarmupFeedParams{ctx, username}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWarmupFeed.t.Errorf("CacheUpdaterMock.WarmupFeed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmWarmupFeed.funcWarmupFeed != nil {
		mmWarmupFeed.funcWarmupFeed(ctx, username)
		return
	}
	mmWarmupFeed.t.Fatalf("Unexpected call to CacheUpdaterMock.WarmupFeed. %v %v", ctx, username)

}

// WarmupFeedAfterCounter returns a count of finished CacheUpdaterMock.WarmupFeed invocations
func (mmWarmupFeed *CacheUpdaterMock) WarmupFeedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarmupFeed.afterWarmupFeedCounter)
}

// WarmupFeedBeforeCounter returns a count of CacheUpdaterMock.WarmupFeed invocations
func (mmWarmupFeed *CacheUpdaterMock) WarmupFeedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWarmupFeed.beforeWarmupFeedCounter)
}

// Calls returns a list of arguments used in each call to CacheUpdaterMock.WarmupFeed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWarmupFeed *mCacheUpdaterMockWarmupFeed) Calls() []*CacheUpdaterMockWarmupFeedParams {
	mmWarmupFeed.mutex.RLock()

	argCopy := make([]*CacheUpdaterMockWarmupFeedParams, len(mmWarmupFeed.callArgs))
	copy(argCopy, mmWarmupFeed.callArgs)

	mmWarmupFeed.mutex.RUnlock()

	return argCopy
}

// MinimockWarmupFeedDone returns true if the count of the WarmupFeed invocations corresponds
// the number of defined expectations
func (m *CacheUpdaterMock) MinimockWarmupFeedDone() bool {
	for _, e := range m.WarmupFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarmupFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarmupFeedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarmupFeed != nil && mm_atomic.LoadUint64(&m.afterWarmupFeedCounter) < 1 {
		return false
	}
	return true
}

// MinimockWarmupFeedInspect logs each unmet expectation
func (m *CacheUpdaterMock) MinimockWarmupFeedInspect() {
	for _, e := range m.WarmupFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheUpdaterMock.WarmupFeed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WarmupFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWarmupFeedCounter) < 1 {
		if m.WarmupFeedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheUpdaterMock.WarmupFeed")
		} else {
			m.t.Errorf("Expected call to CacheUpdaterMock.WarmupFeed with params: %#v", *m.WarmupFeedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWarmupFeed != nil && mm_atomic.LoadUint64(&m.afterWarmupFeedCounter) < 1 {
		m.t.Error("Expected call to CacheUpdaterMock.WarmupFeed")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CacheUpdaterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockWarmupCelebrityFriendsListInspect()

		m.MinimockWarmupFeedInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CacheUpdaterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CacheUpdaterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockWarmupCelebrityFriendsListDone() &&
		m.MinimockWarmupFeedDone()
}
