package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/olgoncharov/otbook/internal/usecase/post/query/feed.configer -o ./internal/usecase/post/query/feed/mocks/configer_mock.go -n ConfigerMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ConfigerMock implements feed.configer
type ConfigerMock struct {
	t minimock.Tester

	funcIsFeedCacheDisabled          func() (b1 bool)
	inspectFuncIsFeedCacheDisabled   func()
	afterIsFeedCacheDisabledCounter  uint64
	beforeIsFeedCacheDisabledCounter uint64
	IsFeedCacheDisabledMock          mConfigerMockIsFeedCacheDisabled

	funcPostFeedLimit          func() (i1 int)
	inspectFuncPostFeedLimit   func()
	afterPostFeedLimitCounter  uint64
	beforePostFeedLimitCounter uint64
	PostFeedLimitMock          mConfigerMockPostFeedLimit
}

// NewConfigerMock returns a mock for feed.configer
func NewConfigerMock(t minimock.Tester) *ConfigerMock {
	m := &ConfigerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IsFeedCacheDisabledMock = mConfigerMockIsFeedCacheDisabled{mock: m}

	m.PostFeedLimitMock = mConfigerMockPostFeedLimit{mock: m}

	return m
}

type mConfigerMockIsFeedCacheDisabled struct {
	mock               *ConfigerMock
	defaultExpectation *ConfigerMockIsFeedCacheDisabledExpectation
	expectations       []*ConfigerMockIsFeedCacheDisabledExpectation
}

// ConfigerMockIsFeedCacheDisabledExpectation specifies expectation struct of the configer.IsFeedCacheDisabled
type ConfigerMockIsFeedCacheDisabledExpectation struct {
	mock *ConfigerMock

	results *ConfigerMockIsFeedCacheDisabledResults
	Counter uint64
}

// ConfigerMockIsFeedCacheDisabledResults contains results of the configer.IsFeedCacheDisabled
type ConfigerMockIsFeedCacheDisabledResults struct {
	b1 bool
}

// Expect sets up expected params for configer.IsFeedCacheDisabled
func (mmIsFeedCacheDisabled *mConfigerMockIsFeedCacheDisabled) Expect() *mConfigerMockIsFeedCacheDisabled {
	if mmIsFeedCacheDisabled.mock.funcIsFeedCacheDisabled != nil {
		mmIsFeedCacheDisabled.mock.t.Fatalf("ConfigerMock.IsFeedCacheDisabled mock is already set by Set")
	}

	if mmIsFeedCacheDisabled.defaultExpectation == nil {
		mmIsFeedCacheDisabled.defaultExpectation = &ConfigerMockIsFeedCacheDisabledExpectation{}
	}

	return mmIsFeedCacheDisabled
}

// Inspect accepts an inspector function that has same arguments as the configer.IsFeedCacheDisabled
func (mmIsFeedCacheDisabled *mConfigerMockIsFeedCacheDisabled) Inspect(f func()) *mConfigerMockIsFeedCacheDisabled {
	if mmIsFeedCacheDisabled.mock.inspectFuncIsFeedCacheDisabled != nil {
		mmIsFeedCacheDisabled.mock.t.Fatalf("Inspect function is already set for ConfigerMock.IsFeedCacheDisabled")
	}

	mmIsFeedCacheDisabled.mock.inspectFuncIsFeedCacheDisabled = f

	return mmIsFeedCacheDisabled
}

// Return sets up results that will be returned by configer.IsFeedCacheDisabled
func (mmIsFeedCacheDisabled *mConfigerMockIsFeedCacheDisabled) Return(b1 bool) *ConfigerMock {
	if mmIsFeedCacheDisabled.mock.funcIsFeedCacheDisabled != nil {
		mmIsFeedCacheDisabled.mock.t.Fatalf("ConfigerMock.IsFeedCacheDisabled mock is already set by Set")
	}

	if mmIsFeedCacheDisabled.defaultExpectation == nil {
		mmIsFeedCacheDisabled.defaultExpectation = &ConfigerMockIsFeedCacheDisabledExpectation{mock: mmIsFeedCacheDisabled.mock}
	}
	mmIsFeedCacheDisabled.defaultExpectation.results = &ConfigerMockIsFeedCacheDisabledResults{b1}
	return mmIsFeedCacheDisabled.mock
}

//Set uses given function f to mock the configer.IsFeedCacheDisabled method
func (mmIsFeedCacheDisabled *mConfigerMockIsFeedCacheDisabled) Set(f func() (b1 bool)) *ConfigerMock {
	if mmIsFeedCacheDisabled.defaultExpectation != nil {
		mmIsFeedCacheDisabled.mock.t.Fatalf("Default expectation is already set for the configer.IsFeedCacheDisabled method")
	}

	if len(mmIsFeedCacheDisabled.expectations) > 0 {
		mmIsFeedCacheDisabled.mock.t.Fatalf("Some expectations are already set for the configer.IsFeedCacheDisabled method")
	}

	mmIsFeedCacheDisabled.mock.funcIsFeedCacheDisabled = f
	return mmIsFeedCacheDisabled.mock
}

// IsFeedCacheDisabled implements feed.configer
func (mmIsFeedCacheDisabled *ConfigerMock) IsFeedCacheDisabled() (b1 bool) {
	mm_atomic.AddUint64(&mmIsFeedCacheDisabled.beforeIsFeedCacheDisabledCounter, 1)
	defer mm_atomic.AddUint64(&mmIsFeedCacheDisabled.afterIsFeedCacheDisabledCounter, 1)

	if mmIsFeedCacheDisabled.inspectFuncIsFeedCacheDisabled != nil {
		mmIsFeedCacheDisabled.inspectFuncIsFeedCacheDisabled()
	}

	if mmIsFeedCacheDisabled.IsFeedCacheDisabledMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsFeedCacheDisabled.IsFeedCacheDisabledMock.defaultExpectation.Counter, 1)

		mm_results := mmIsFeedCacheDisabled.IsFeedCacheDisabledMock.defaultExpectation.results
		if mm_results == nil {
			mmIsFeedCacheDisabled.t.Fatal("No results are set for the ConfigerMock.IsFeedCacheDisabled")
		}
		return (*mm_results).b1
	}
	if mmIsFeedCacheDisabled.funcIsFeedCacheDisabled != nil {
		return mmIsFeedCacheDisabled.funcIsFeedCacheDisabled()
	}
	mmIsFeedCacheDisabled.t.Fatalf("Unexpected call to ConfigerMock.IsFeedCacheDisabled.")
	return
}

// IsFeedCacheDisabledAfterCounter returns a count of finished ConfigerMock.IsFeedCacheDisabled invocations
func (mmIsFeedCacheDisabled *ConfigerMock) IsFeedCacheDisabledAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsFeedCacheDisabled.afterIsFeedCacheDisabledCounter)
}

// IsFeedCacheDisabledBeforeCounter returns a count of ConfigerMock.IsFeedCacheDisabled invocations
func (mmIsFeedCacheDisabled *ConfigerMock) IsFeedCacheDisabledBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsFeedCacheDisabled.beforeIsFeedCacheDisabledCounter)
}

// MinimockIsFeedCacheDisabledDone returns true if the count of the IsFeedCacheDisabled invocations corresponds
// the number of defined expectations
func (m *ConfigerMock) MinimockIsFeedCacheDisabledDone() bool {
	for _, e := range m.IsFeedCacheDisabledMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsFeedCacheDisabledMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsFeedCacheDisabledCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsFeedCacheDisabled != nil && mm_atomic.LoadUint64(&m.afterIsFeedCacheDisabledCounter) < 1 {
		return false
	}
	return true
}

// MinimockIsFeedCacheDisabledInspect logs each unmet expectation
func (m *ConfigerMock) MinimockIsFeedCacheDisabledInspect() {
	for _, e := range m.IsFeedCacheDisabledMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConfigerMock.IsFeedCacheDisabled")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IsFeedCacheDisabledMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIsFeedCacheDisabledCounter) < 1 {
		m.t.Error("Expected call to ConfigerMock.IsFeedCacheDisabled")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsFeedCacheDisabled != nil && mm_atomic.LoadUint64(&m.afterIsFeedCacheDisabledCounter) < 1 {
		m.t.Error("Expected call to ConfigerMock.IsFeedCacheDisabled")
	}
}

type mConfigerMockPostFeedLimit struct {
	mock               *ConfigerMock
	defaultExpectation *ConfigerMockPostFeedLimitExpectation
	expectations       []*ConfigerMockPostFeedLimitExpectation
}

// ConfigerMockPostFeedLimitExpectation specifies expectation struct of the configer.PostFeedLimit
type ConfigerMockPostFeedLimitExpectation struct {
	mock *ConfigerMock

	results *ConfigerMockPostFeedLimitResults
	Counter uint64
}

// ConfigerMockPostFeedLimitResults contains results of the configer.PostFeedLimit
type ConfigerMockPostFeedLimitResults struct {
	i1 int
}

// Expect sets up expected params for configer.PostFeedLimit
func (mmPostFeedLimit *mConfigerMockPostFeedLimit) Expect() *mConfigerMockPostFeedLimit {
	if mmPostFeedLimit.mock.funcPostFeedLimit != nil {
		mmPostFeedLimit.mock.t.Fatalf("ConfigerMock.PostFeedLimit mock is already set by Set")
	}

	if mmPostFeedLimit.defaultExpectation == nil {
		mmPostFeedLimit.defaultExpectation = &ConfigerMockPostFeedLimitExpectation{}
	}

	return mmPostFeedLimit
}

// Inspect accepts an inspector function that has same arguments as the configer.PostFeedLimit
func (mmPostFeedLimit *mConfigerMockPostFeedLimit) Inspect(f func()) *mConfigerMockPostFeedLimit {
	if mmPostFeedLimit.mock.inspectFuncPostFeedLimit != nil {
		mmPostFeedLimit.mock.t.Fatalf("Inspect function is already set for ConfigerMock.PostFeedLimit")
	}

	mmPostFeedLimit.mock.inspectFuncPostFeedLimit = f

	return mmPostFeedLimit
}

// Return sets up results that will be returned by configer.PostFeedLimit
func (mmPostFeedLimit *mConfigerMockPostFeedLimit) Return(i1 int) *ConfigerMock {
	if mmPostFeedLimit.mock.funcPostFeedLimit != nil {
		mmPostFeedLimit.mock.t.Fatalf("ConfigerMock.PostFeedLimit mock is already set by Set")
	}

	if mmPostFeedLimit.defaultExpectation == nil {
		mmPostFeedLimit.defaultExpectation = &ConfigerMockPostFeedLimitExpectation{mock: mmPostFeedLimit.mock}
	}
	mmPostFeedLimit.defaultExpectation.results = &ConfigerMockPostFeedLimitResults{i1}
	return mmPostFeedLimit.mock
}

//Set uses given function f to mock the configer.PostFeedLimit method
func (mmPostFeedLimit *mConfigerMockPostFeedLimit) Set(f func() (i1 int)) *ConfigerMock {
	if mmPostFeedLimit.defaultExpectation != nil {
		mmPostFeedLimit.mock.t.Fatalf("Default expectation is already set for the configer.PostFeedLimit method")
	}

	if len(mmPostFeedLimit.expectations) > 0 {
		mmPostFeedLimit.mock.t.Fatalf("Some expectations are already set for the configer.PostFeedLimit method")
	}

	mmPostFeedLimit.mock.funcPostFeedLimit = f
	return mmPostFeedLimit.mock
}

// PostFeedLimit implements feed.configer
func (mmPostFeedLimit *ConfigerMock) PostFeedLimit() (i1 int) {
	mm_atomic.AddUint64(&mmPostFeedLimit.beforePostFeedLimitCounter, 1)
	defer mm_atomic.AddUint64(&mmPostFeedLimit.afterPostFeedLimitCounter, 1)

	if mmPostFeedLimit.inspectFuncPostFeedLimit != nil {
		mmPostFeedLimit.inspectFuncPostFeedLimit()
	}

	if mmPostFeedLimit.PostFeedLimitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPostFeedLimit.PostFeedLimitMock.defaultExpectation.Counter, 1)

		mm_results := mmPostFeedLimit.PostFeedLimitMock.defaultExpectation.results
		if mm_results == nil {
			mmPostFeedLimit.t.Fatal("No results are set for the ConfigerMock.PostFeedLimit")
		}
		return (*mm_results).i1
	}
	if mmPostFeedLimit.funcPostFeedLimit != nil {
		return mmPostFeedLimit.funcPostFeedLimit()
	}
	mmPostFeedLimit.t.Fatalf("Unexpected call to ConfigerMock.PostFeedLimit.")
	return
}

// PostFeedLimitAfterCounter returns a count of finished ConfigerMock.PostFeedLimit invocations
func (mmPostFeedLimit *ConfigerMock) PostFeedLimitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPostFeedLimit.afterPostFeedLimitCounter)
}

// PostFeedLimitBeforeCounter returns a count of ConfigerMock.PostFeedLimit invocations
func (mmPostFeedLimit *ConfigerMock) PostFeedLimitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPostFeedLimit.beforePostFeedLimitCounter)
}

// MinimockPostFeedLimitDone returns true if the count of the PostFeedLimit invocations corresponds
// the number of defined expectations
func (m *ConfigerMock) MinimockPostFeedLimitDone() bool {
	for _, e := range m.PostFeedLimitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PostFeedLimitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPostFeedLimitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPostFeedLimit != nil && mm_atomic.LoadUint64(&m.afterPostFeedLimitCounter) < 1 {
		return false
	}
	return true
}

// MinimockPostFeedLimitInspect logs each unmet expectation
func (m *ConfigerMock) MinimockPostFeedLimitInspect() {
	for _, e := range m.PostFeedLimitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConfigerMock.PostFeedLimit")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PostFeedLimitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPostFeedLimitCounter) < 1 {
		m.t.Error("Expected call to ConfigerMock.PostFeedLimit")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPostFeedLimit != nil && mm_atomic.LoadUint64(&m.afterPostFeedLimitCounter) < 1 {
		m.t.Error("Expected call to ConfigerMock.PostFeedLimit")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConfigerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockIsFeedCacheDisabledInspect()

		m.MinimockPostFeedLimitInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConfigerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConfigerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIsFeedCacheDisabledDone() &&
		m.MinimockPostFeedLimitDone()
}
