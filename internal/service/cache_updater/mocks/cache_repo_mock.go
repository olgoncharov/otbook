package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/olgoncharov/otbook/internal/service/cache_updater.cacheRepo -o ./internal/service/cache_updater/mocks/cache_repo_mock.go -n CacheRepoMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/olgoncharov/otbook/internal/entity"
	"github.com/olgoncharov/otbook/internal/repository/dto"
)

// CacheRepoMock implements cacheupdater.cacheRepo
type CacheRepoMock struct {
	t minimock.Tester

	funcAddCelebrityFriend          func(ctx context.Context, user string, friend string) (err error)
	inspectFuncAddCelebrityFriend   func(ctx context.Context, user string, friend string)
	afterAddCelebrityFriendCounter  uint64
	beforeAddCelebrityFriendCounter uint64
	AddCelebrityFriendMock          mCacheRepoMockAddCelebrityFriend

	funcDeleteCelebrityFriend          func(ctx context.Context, user string, friend string) (err error)
	inspectFuncDeleteCelebrityFriend   func(ctx context.Context, user string, friend string)
	afterDeleteCelebrityFriendCounter  uint64
	beforeDeleteCelebrityFriendCounter uint64
	DeleteCelebrityFriendMock          mCacheRepoMockDeleteCelebrityFriend

	funcDeletePostsFromFeed          func(ctx context.Context, username string, posts []dto.PostShortInfo) (err error)
	inspectFuncDeletePostsFromFeed   func(ctx context.Context, username string, posts []dto.PostShortInfo)
	afterDeletePostsFromFeedCounter  uint64
	beforeDeletePostsFromFeedCounter uint64
	DeletePostsFromFeedMock          mCacheRepoMockDeletePostsFromFeed

	funcGetPostFeed          func(ctx context.Context, username string, limit uint) (pa1 []dto.PostShortInfo, err error)
	inspectFuncGetPostFeed   func(ctx context.Context, username string, limit uint)
	afterGetPostFeedCounter  uint64
	beforeGetPostFeedCounter uint64
	GetPostFeedMock          mCacheRepoMockGetPostFeed

	funcPushPostToFeed          func(ctx context.Context, post entity.Post, usernames []string, feedLimit uint) (err error)
	inspectFuncPushPostToFeed   func(ctx context.Context, post entity.Post, usernames []string, feedLimit uint)
	afterPushPostToFeedCounter  uint64
	beforePushPostToFeedCounter uint64
	PushPostToFeedMock          mCacheRepoMockPushPostToFeed

	funcSetCelebrityFriends          func(ctx context.Context, usercname string, friends []string) (err error)
	inspectFuncSetCelebrityFriends   func(ctx context.Context, usercname string, friends []string)
	afterSetCelebrityFriendsCounter  uint64
	beforeSetCelebrityFriendsCounter uint64
	SetCelebrityFriendsMock          mCacheRepoMockSetCelebrityFriends

	funcSetPostFeed          func(ctx context.Context, username string, posts []dto.PostShortInfo) (err error)
	inspectFuncSetPostFeed   func(ctx context.Context, username string, posts []dto.PostShortInfo)
	afterSetPostFeedCounter  uint64
	beforeSetPostFeedCounter uint64
	SetPostFeedMock          mCacheRepoMockSetPostFeed
}

// NewCacheRepoMock returns a mock for cacheupdater.cacheRepo
func NewCacheRepoMock(t minimock.Tester) *CacheRepoMock {
	m := &CacheRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCelebrityFriendMock = mCacheRepoMockAddCelebrityFriend{mock: m}
	m.AddCelebrityFriendMock.callArgs = []*CacheRepoMockAddCelebrityFriendParams{}

	m.DeleteCelebrityFriendMock = mCacheRepoMockDeleteCelebrityFriend{mock: m}
	m.DeleteCelebrityFriendMock.callArgs = []*CacheRepoMockDeleteCelebrityFriendParams{}

	m.DeletePostsFromFeedMock = mCacheRepoMockDeletePostsFromFeed{mock: m}
	m.DeletePostsFromFeedMock.callArgs = []*CacheRepoMockDeletePostsFromFeedParams{}

	m.GetPostFeedMock = mCacheRepoMockGetPostFeed{mock: m}
	m.GetPostFeedMock.callArgs = []*CacheRepoMockGetPostFeedParams{}

	m.PushPostToFeedMock = mCacheRepoMockPushPostToFeed{mock: m}
	m.PushPostToFeedMock.callArgs = []*CacheRepoMockPushPostToFeedParams{}

	m.SetCelebrityFriendsMock = mCacheRepoMockSetCelebrityFriends{mock: m}
	m.SetCelebrityFriendsMock.callArgs = []*CacheRepoMockSetCelebrityFriendsParams{}

	m.SetPostFeedMock = mCacheRepoMockSetPostFeed{mock: m}
	m.SetPostFeedMock.callArgs = []*CacheRepoMockSetPostFeedParams{}

	return m
}

type mCacheRepoMockAddCelebrityFriend struct {
	mock               *CacheRepoMock
	defaultExpectation *CacheRepoMockAddCelebrityFriendExpectation
	expectations       []*CacheRepoMockAddCelebrityFriendExpectation

	callArgs []*CacheRepoMockAddCelebrityFriendParams
	mutex    sync.RWMutex
}

// CacheRepoMockAddCelebrityFriendExpectation specifies expectation struct of the cacheRepo.AddCelebrityFriend
type CacheRepoMockAddCelebrityFriendExpectation struct {
	mock    *CacheRepoMock
	params  *CacheRepoMockAddCelebrityFriendParams
	results *CacheRepoMockAddCelebrityFriendResults
	Counter uint64
}

// CacheRepoMockAddCelebrityFriendParams contains parameters of the cacheRepo.AddCelebrityFriend
type CacheRepoMockAddCelebrityFriendParams struct {
	ctx    context.Context
	user   string
	friend string
}

// CacheRepoMockAddCelebrityFriendResults contains results of the cacheRepo.AddCelebrityFriend
type CacheRepoMockAddCelebrityFriendResults struct {
	err error
}

// Expect sets up expected params for cacheRepo.AddCelebrityFriend
func (mmAddCelebrityFriend *mCacheRepoMockAddCelebrityFriend) Expect(ctx context.Context, user string, friend string) *mCacheRepoMockAddCelebrityFriend {
	if mmAddCelebrityFriend.mock.funcAddCelebrityFriend != nil {
		mmAddCelebrityFriend.mock.t.Fatalf("CacheRepoMock.AddCelebrityFriend mock is already set by Set")
	}

	if mmAddCelebrityFriend.defaultExpectation == nil {
		mmAddCelebrityFriend.defaultExpectation = &CacheRepoMockAddCelebrityFriendExpectation{}
	}

	mmAddCelebrityFriend.defaultExpectation.params = &CacheRepoMockAddCelebrityFriendParams{ctx, user, friend}
	for _, e := range mmAddCelebrityFriend.expectations {
		if minimock.Equal(e.params, mmAddCelebrityFriend.defaultExpectation.params) {
			mmAddCelebrityFriend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddCelebrityFriend.defaultExpectation.params)
		}
	}

	return mmAddCelebrityFriend
}

// Inspect accepts an inspector function that has same arguments as the cacheRepo.AddCelebrityFriend
func (mmAddCelebrityFriend *mCacheRepoMockAddCelebrityFriend) Inspect(f func(ctx context.Context, user string, friend string)) *mCacheRepoMockAddCelebrityFriend {
	if mmAddCelebrityFriend.mock.inspectFuncAddCelebrityFriend != nil {
		mmAddCelebrityFriend.mock.t.Fatalf("Inspect function is already set for CacheRepoMock.AddCelebrityFriend")
	}

	mmAddCelebrityFriend.mock.inspectFuncAddCelebrityFriend = f

	return mmAddCelebrityFriend
}

// Return sets up results that will be returned by cacheRepo.AddCelebrityFriend
func (mmAddCelebrityFriend *mCacheRepoMockAddCelebrityFriend) Return(err error) *CacheRepoMock {
	if mmAddCelebrityFriend.mock.funcAddCelebrityFriend != nil {
		mmAddCelebrityFriend.mock.t.Fatalf("CacheRepoMock.AddCelebrityFriend mock is already set by Set")
	}

	if mmAddCelebrityFriend.defaultExpectation == nil {
		mmAddCelebrityFriend.defaultExpectation = &CacheRepoMockAddCelebrityFriendExpectation{mock: mmAddCelebrityFriend.mock}
	}
	mmAddCelebrityFriend.defaultExpectation.results = &CacheRepoMockAddCelebrityFriendResults{err}
	return mmAddCelebrityFriend.mock
}

//Set uses given function f to mock the cacheRepo.AddCelebrityFriend method
func (mmAddCelebrityFriend *mCacheRepoMockAddCelebrityFriend) Set(f func(ctx context.Context, user string, friend string) (err error)) *CacheRepoMock {
	if mmAddCelebrityFriend.defaultExpectation != nil {
		mmAddCelebrityFriend.mock.t.Fatalf("Default expectation is already set for the cacheRepo.AddCelebrityFriend method")
	}

	if len(mmAddCelebrityFriend.expectations) > 0 {
		mmAddCelebrityFriend.mock.t.Fatalf("Some expectations are already set for the cacheRepo.AddCelebrityFriend method")
	}

	mmAddCelebrityFriend.mock.funcAddCelebrityFriend = f
	return mmAddCelebrityFriend.mock
}

// When sets expectation for the cacheRepo.AddCelebrityFriend which will trigger the result defined by the following
// Then helper
func (mmAddCelebrityFriend *mCacheRepoMockAddCelebrityFriend) When(ctx context.Context, user string, friend string) *CacheRepoMockAddCelebrityFriendExpectation {
	if mmAddCelebrityFriend.mock.funcAddCelebrityFriend != nil {
		mmAddCelebrityFriend.mock.t.Fatalf("CacheRepoMock.AddCelebrityFriend mock is already set by Set")
	}

	expectation := &CacheRepoMockAddCelebrityFriendExpectation{
		mock:   mmAddCelebrityFriend.mock,
		params: &CacheRepoMockAddCelebrityFriendParams{ctx, user, friend},
	}
	mmAddCelebrityFriend.expectations = append(mmAddCelebrityFriend.expectations, expectation)
	return expectation
}

// Then sets up cacheRepo.AddCelebrityFriend return parameters for the expectation previously defined by the When method
func (e *CacheRepoMockAddCelebrityFriendExpectation) Then(err error) *CacheRepoMock {
	e.results = &CacheRepoMockAddCelebrityFriendResults{err}
	return e.mock
}

// AddCelebrityFriend implements cacheupdater.cacheRepo
func (mmAddCelebrityFriend *CacheRepoMock) AddCelebrityFriend(ctx context.Context, user string, friend string) (err error) {
	mm_atomic.AddUint64(&mmAddCelebrityFriend.beforeAddCelebrityFriendCounter, 1)
	defer mm_atomic.AddUint64(&mmAddCelebrityFriend.afterAddCelebrityFriendCounter, 1)

	if mmAddCelebrityFriend.inspectFuncAddCelebrityFriend != nil {
		mmAddCelebrityFriend.inspectFuncAddCelebrityFriend(ctx, user, friend)
	}

	mm_params := &CacheRepoMockAddCelebrityFriendParams{ctx, user, friend}

	// Record call args
	mmAddCelebrityFriend.AddCelebrityFriendMock.mutex.Lock()
	mmAddCelebrityFriend.AddCelebrityFriendMock.callArgs = append(mmAddCelebrityFriend.AddCelebrityFriendMock.callArgs, mm_params)
	mmAddCelebrityFriend.AddCelebrityFriendMock.mutex.Unlock()

	for _, e := range mmAddCelebrityFriend.AddCelebrityFriendMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddCelebrityFriend.AddCelebrityFriendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddCelebrityFriend.AddCelebrityFriendMock.defaultExpectation.Counter, 1)
		mm_want := mmAddCelebrityFriend.AddCelebrityFriendMock.defaultExpectation.params
		mm_got := CacheRepoMockAddCelebrityFriendParams{ctx, user, friend}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddCelebrityFriend.t.Errorf("CacheRepoMock.AddCelebrityFriend got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddCelebrityFriend.AddCelebrityFriendMock.defaultExpectation.results
		if mm_results == nil {
			mmAddCelebrityFriend.t.Fatal("No results are set for the CacheRepoMock.AddCelebrityFriend")
		}
		return (*mm_results).err
	}
	if mmAddCelebrityFriend.funcAddCelebrityFriend != nil {
		return mmAddCelebrityFriend.funcAddCelebrityFriend(ctx, user, friend)
	}
	mmAddCelebrityFriend.t.Fatalf("Unexpected call to CacheRepoMock.AddCelebrityFriend. %v %v %v", ctx, user, friend)
	return
}

// AddCelebrityFriendAfterCounter returns a count of finished CacheRepoMock.AddCelebrityFriend invocations
func (mmAddCelebrityFriend *CacheRepoMock) AddCelebrityFriendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCelebrityFriend.afterAddCelebrityFriendCounter)
}

// AddCelebrityFriendBeforeCounter returns a count of CacheRepoMock.AddCelebrityFriend invocations
func (mmAddCelebrityFriend *CacheRepoMock) AddCelebrityFriendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCelebrityFriend.beforeAddCelebrityFriendCounter)
}

// Calls returns a list of arguments used in each call to CacheRepoMock.AddCelebrityFriend.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddCelebrityFriend *mCacheRepoMockAddCelebrityFriend) Calls() []*CacheRepoMockAddCelebrityFriendParams {
	mmAddCelebrityFriend.mutex.RLock()

	argCopy := make([]*CacheRepoMockAddCelebrityFriendParams, len(mmAddCelebrityFriend.callArgs))
	copy(argCopy, mmAddCelebrityFriend.callArgs)

	mmAddCelebrityFriend.mutex.RUnlock()

	return argCopy
}

// MinimockAddCelebrityFriendDone returns true if the count of the AddCelebrityFriend invocations corresponds
// the number of defined expectations
func (m *CacheRepoMock) MinimockAddCelebrityFriendDone() bool {
	for _, e := range m.AddCelebrityFriendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddCelebrityFriendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCelebrityFriendCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCelebrityFriend != nil && mm_atomic.LoadUint64(&m.afterAddCelebrityFriendCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddCelebrityFriendInspect logs each unmet expectation
func (m *CacheRepoMock) MinimockAddCelebrityFriendInspect() {
	for _, e := range m.AddCelebrityFriendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheRepoMock.AddCelebrityFriend with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddCelebrityFriendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCelebrityFriendCounter) < 1 {
		if m.AddCelebrityFriendMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheRepoMock.AddCelebrityFriend")
		} else {
			m.t.Errorf("Expected call to CacheRepoMock.AddCelebrityFriend with params: %#v", *m.AddCelebrityFriendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCelebrityFriend != nil && mm_atomic.LoadUint64(&m.afterAddCelebrityFriendCounter) < 1 {
		m.t.Error("Expected call to CacheRepoMock.AddCelebrityFriend")
	}
}

type mCacheRepoMockDeleteCelebrityFriend struct {
	mock               *CacheRepoMock
	defaultExpectation *CacheRepoMockDeleteCelebrityFriendExpectation
	expectations       []*CacheRepoMockDeleteCelebrityFriendExpectation

	callArgs []*CacheRepoMockDeleteCelebrityFriendParams
	mutex    sync.RWMutex
}

// CacheRepoMockDeleteCelebrityFriendExpectation specifies expectation struct of the cacheRepo.DeleteCelebrityFriend
type CacheRepoMockDeleteCelebrityFriendExpectation struct {
	mock    *CacheRepoMock
	params  *CacheRepoMockDeleteCelebrityFriendParams
	results *CacheRepoMockDeleteCelebrityFriendResults
	Counter uint64
}

// CacheRepoMockDeleteCelebrityFriendParams contains parameters of the cacheRepo.DeleteCelebrityFriend
type CacheRepoMockDeleteCelebrityFriendParams struct {
	ctx    context.Context
	user   string
	friend string
}

// CacheRepoMockDeleteCelebrityFriendResults contains results of the cacheRepo.DeleteCelebrityFriend
type CacheRepoMockDeleteCelebrityFriendResults struct {
	err error
}

// Expect sets up expected params for cacheRepo.DeleteCelebrityFriend
func (mmDeleteCelebrityFriend *mCacheRepoMockDeleteCelebrityFriend) Expect(ctx context.Context, user string, friend string) *mCacheRepoMockDeleteCelebrityFriend {
	if mmDeleteCelebrityFriend.mock.funcDeleteCelebrityFriend != nil {
		mmDeleteCelebrityFriend.mock.t.Fatalf("CacheRepoMock.DeleteCelebrityFriend mock is already set by Set")
	}

	if mmDeleteCelebrityFriend.defaultExpectation == nil {
		mmDeleteCelebrityFriend.defaultExpectation = &CacheRepoMockDeleteCelebrityFriendExpectation{}
	}

	mmDeleteCelebrityFriend.defaultExpectation.params = &CacheRepoMockDeleteCelebrityFriendParams{ctx, user, friend}
	for _, e := range mmDeleteCelebrityFriend.expectations {
		if minimock.Equal(e.params, mmDeleteCelebrityFriend.defaultExpectation.params) {
			mmDeleteCelebrityFriend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCelebrityFriend.defaultExpectation.params)
		}
	}

	return mmDeleteCelebrityFriend
}

// Inspect accepts an inspector function that has same arguments as the cacheRepo.DeleteCelebrityFriend
func (mmDeleteCelebrityFriend *mCacheRepoMockDeleteCelebrityFriend) Inspect(f func(ctx context.Context, user string, friend string)) *mCacheRepoMockDeleteCelebrityFriend {
	if mmDeleteCelebrityFriend.mock.inspectFuncDeleteCelebrityFriend != nil {
		mmDeleteCelebrityFriend.mock.t.Fatalf("Inspect function is already set for CacheRepoMock.DeleteCelebrityFriend")
	}

	mmDeleteCelebrityFriend.mock.inspectFuncDeleteCelebrityFriend = f

	return mmDeleteCelebrityFriend
}

// Return sets up results that will be returned by cacheRepo.DeleteCelebrityFriend
func (mmDeleteCelebrityFriend *mCacheRepoMockDeleteCelebrityFriend) Return(err error) *CacheRepoMock {
	if mmDeleteCelebrityFriend.mock.funcDeleteCelebrityFriend != nil {
		mmDeleteCelebrityFriend.mock.t.Fatalf("CacheRepoMock.DeleteCelebrityFriend mock is already set by Set")
	}

	if mmDeleteCelebrityFriend.defaultExpectation == nil {
		mmDeleteCelebrityFriend.defaultExpectation = &CacheRepoMockDeleteCelebrityFriendExpectation{mock: mmDeleteCelebrityFriend.mock}
	}
	mmDeleteCelebrityFriend.defaultExpectation.results = &CacheRepoMockDeleteCelebrityFriendResults{err}
	return mmDeleteCelebrityFriend.mock
}

//Set uses given function f to mock the cacheRepo.DeleteCelebrityFriend method
func (mmDeleteCelebrityFriend *mCacheRepoMockDeleteCelebrityFriend) Set(f func(ctx context.Context, user string, friend string) (err error)) *CacheRepoMock {
	if mmDeleteCelebrityFriend.defaultExpectation != nil {
		mmDeleteCelebrityFriend.mock.t.Fatalf("Default expectation is already set for the cacheRepo.DeleteCelebrityFriend method")
	}

	if len(mmDeleteCelebrityFriend.expectations) > 0 {
		mmDeleteCelebrityFriend.mock.t.Fatalf("Some expectations are already set for the cacheRepo.DeleteCelebrityFriend method")
	}

	mmDeleteCelebrityFriend.mock.funcDeleteCelebrityFriend = f
	return mmDeleteCelebrityFriend.mock
}

// When sets expectation for the cacheRepo.DeleteCelebrityFriend which will trigger the result defined by the following
// Then helper
func (mmDeleteCelebrityFriend *mCacheRepoMockDeleteCelebrityFriend) When(ctx context.Context, user string, friend string) *CacheRepoMockDeleteCelebrityFriendExpectation {
	if mmDeleteCelebrityFriend.mock.funcDeleteCelebrityFriend != nil {
		mmDeleteCelebrityFriend.mock.t.Fatalf("CacheRepoMock.DeleteCelebrityFriend mock is already set by Set")
	}

	expectation := &CacheRepoMockDeleteCelebrityFriendExpectation{
		mock:   mmDeleteCelebrityFriend.mock,
		params: &CacheRepoMockDeleteCelebrityFriendParams{ctx, user, friend},
	}
	mmDeleteCelebrityFriend.expectations = append(mmDeleteCelebrityFriend.expectations, expectation)
	return expectation
}

// Then sets up cacheRepo.DeleteCelebrityFriend return parameters for the expectation previously defined by the When method
func (e *CacheRepoMockDeleteCelebrityFriendExpectation) Then(err error) *CacheRepoMock {
	e.results = &CacheRepoMockDeleteCelebrityFriendResults{err}
	return e.mock
}

// DeleteCelebrityFriend implements cacheupdater.cacheRepo
func (mmDeleteCelebrityFriend *CacheRepoMock) DeleteCelebrityFriend(ctx context.Context, user string, friend string) (err error) {
	mm_atomic.AddUint64(&mmDeleteCelebrityFriend.beforeDeleteCelebrityFriendCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCelebrityFriend.afterDeleteCelebrityFriendCounter, 1)

	if mmDeleteCelebrityFriend.inspectFuncDeleteCelebrityFriend != nil {
		mmDeleteCelebrityFriend.inspectFuncDeleteCelebrityFriend(ctx, user, friend)
	}

	mm_params := &CacheRepoMockDeleteCelebrityFriendParams{ctx, user, friend}

	// Record call args
	mmDeleteCelebrityFriend.DeleteCelebrityFriendMock.mutex.Lock()
	mmDeleteCelebrityFriend.DeleteCelebrityFriendMock.callArgs = append(mmDeleteCelebrityFriend.DeleteCelebrityFriendMock.callArgs, mm_params)
	mmDeleteCelebrityFriend.DeleteCelebrityFriendMock.mutex.Unlock()

	for _, e := range mmDeleteCelebrityFriend.DeleteCelebrityFriendMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCelebrityFriend.DeleteCelebrityFriendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCelebrityFriend.DeleteCelebrityFriendMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCelebrityFriend.DeleteCelebrityFriendMock.defaultExpectation.params
		mm_got := CacheRepoMockDeleteCelebrityFriendParams{ctx, user, friend}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCelebrityFriend.t.Errorf("CacheRepoMock.DeleteCelebrityFriend got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCelebrityFriend.DeleteCelebrityFriendMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCelebrityFriend.t.Fatal("No results are set for the CacheRepoMock.DeleteCelebrityFriend")
		}
		return (*mm_results).err
	}
	if mmDeleteCelebrityFriend.funcDeleteCelebrityFriend != nil {
		return mmDeleteCelebrityFriend.funcDeleteCelebrityFriend(ctx, user, friend)
	}
	mmDeleteCelebrityFriend.t.Fatalf("Unexpected call to CacheRepoMock.DeleteCelebrityFriend. %v %v %v", ctx, user, friend)
	return
}

// DeleteCelebrityFriendAfterCounter returns a count of finished CacheRepoMock.DeleteCelebrityFriend invocations
func (mmDeleteCelebrityFriend *CacheRepoMock) DeleteCelebrityFriendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCelebrityFriend.afterDeleteCelebrityFriendCounter)
}

// DeleteCelebrityFriendBeforeCounter returns a count of CacheRepoMock.DeleteCelebrityFriend invocations
func (mmDeleteCelebrityFriend *CacheRepoMock) DeleteCelebrityFriendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCelebrityFriend.beforeDeleteCelebrityFriendCounter)
}

// Calls returns a list of arguments used in each call to CacheRepoMock.DeleteCelebrityFriend.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCelebrityFriend *mCacheRepoMockDeleteCelebrityFriend) Calls() []*CacheRepoMockDeleteCelebrityFriendParams {
	mmDeleteCelebrityFriend.mutex.RLock()

	argCopy := make([]*CacheRepoMockDeleteCelebrityFriendParams, len(mmDeleteCelebrityFriend.callArgs))
	copy(argCopy, mmDeleteCelebrityFriend.callArgs)

	mmDeleteCelebrityFriend.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCelebrityFriendDone returns true if the count of the DeleteCelebrityFriend invocations corresponds
// the number of defined expectations
func (m *CacheRepoMock) MinimockDeleteCelebrityFriendDone() bool {
	for _, e := range m.DeleteCelebrityFriendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCelebrityFriendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCelebrityFriendCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCelebrityFriend != nil && mm_atomic.LoadUint64(&m.afterDeleteCelebrityFriendCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteCelebrityFriendInspect logs each unmet expectation
func (m *CacheRepoMock) MinimockDeleteCelebrityFriendInspect() {
	for _, e := range m.DeleteCelebrityFriendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheRepoMock.DeleteCelebrityFriend with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCelebrityFriendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCelebrityFriendCounter) < 1 {
		if m.DeleteCelebrityFriendMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheRepoMock.DeleteCelebrityFriend")
		} else {
			m.t.Errorf("Expected call to CacheRepoMock.DeleteCelebrityFriend with params: %#v", *m.DeleteCelebrityFriendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCelebrityFriend != nil && mm_atomic.LoadUint64(&m.afterDeleteCelebrityFriendCounter) < 1 {
		m.t.Error("Expected call to CacheRepoMock.DeleteCelebrityFriend")
	}
}

type mCacheRepoMockDeletePostsFromFeed struct {
	mock               *CacheRepoMock
	defaultExpectation *CacheRepoMockDeletePostsFromFeedExpectation
	expectations       []*CacheRepoMockDeletePostsFromFeedExpectation

	callArgs []*CacheRepoMockDeletePostsFromFeedParams
	mutex    sync.RWMutex
}

// CacheRepoMockDeletePostsFromFeedExpectation specifies expectation struct of the cacheRepo.DeletePostsFromFeed
type CacheRepoMockDeletePostsFromFeedExpectation struct {
	mock    *CacheRepoMock
	params  *CacheRepoMockDeletePostsFromFeedParams
	results *CacheRepoMockDeletePostsFromFeedResults
	Counter uint64
}

// CacheRepoMockDeletePostsFromFeedParams contains parameters of the cacheRepo.DeletePostsFromFeed
type CacheRepoMockDeletePostsFromFeedParams struct {
	ctx      context.Context
	username string
	posts    []dto.PostShortInfo
}

// CacheRepoMockDeletePostsFromFeedResults contains results of the cacheRepo.DeletePostsFromFeed
type CacheRepoMockDeletePostsFromFeedResults struct {
	err error
}

// Expect sets up expected params for cacheRepo.DeletePostsFromFeed
func (mmDeletePostsFromFeed *mCacheRepoMockDeletePostsFromFeed) Expect(ctx context.Context, username string, posts []dto.PostShortInfo) *mCacheRepoMockDeletePostsFromFeed {
	if mmDeletePostsFromFeed.mock.funcDeletePostsFromFeed != nil {
		mmDeletePostsFromFeed.mock.t.Fatalf("CacheRepoMock.DeletePostsFromFeed mock is already set by Set")
	}

	if mmDeletePostsFromFeed.defaultExpectation == nil {
		mmDeletePostsFromFeed.defaultExpectation = &CacheRepoMockDeletePostsFromFeedExpectation{}
	}

	mmDeletePostsFromFeed.defaultExpectation.params = &CacheRepoMockDeletePostsFromFeedParams{ctx, username, posts}
	for _, e := range mmDeletePostsFromFeed.expectations {
		if minimock.Equal(e.params, mmDeletePostsFromFeed.defaultExpectation.params) {
			mmDeletePostsFromFeed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePostsFromFeed.defaultExpectation.params)
		}
	}

	return mmDeletePostsFromFeed
}

// Inspect accepts an inspector function that has same arguments as the cacheRepo.DeletePostsFromFeed
func (mmDeletePostsFromFeed *mCacheRepoMockDeletePostsFromFeed) Inspect(f func(ctx context.Context, username string, posts []dto.PostShortInfo)) *mCacheRepoMockDeletePostsFromFeed {
	if mmDeletePostsFromFeed.mock.inspectFuncDeletePostsFromFeed != nil {
		mmDeletePostsFromFeed.mock.t.Fatalf("Inspect function is already set for CacheRepoMock.DeletePostsFromFeed")
	}

	mmDeletePostsFromFeed.mock.inspectFuncDeletePostsFromFeed = f

	return mmDeletePostsFromFeed
}

// Return sets up results that will be returned by cacheRepo.DeletePostsFromFeed
func (mmDeletePostsFromFeed *mCacheRepoMockDeletePostsFromFeed) Return(err error) *CacheRepoMock {
	if mmDeletePostsFromFeed.mock.funcDeletePostsFromFeed != nil {
		mmDeletePostsFromFeed.mock.t.Fatalf("CacheRepoMock.DeletePostsFromFeed mock is already set by Set")
	}

	if mmDeletePostsFromFeed.defaultExpectation == nil {
		mmDeletePostsFromFeed.defaultExpectation = &CacheRepoMockDeletePostsFromFeedExpectation{mock: mmDeletePostsFromFeed.mock}
	}
	mmDeletePostsFromFeed.defaultExpectation.results = &CacheRepoMockDeletePostsFromFeedResults{err}
	return mmDeletePostsFromFeed.mock
}

//Set uses given function f to mock the cacheRepo.DeletePostsFromFeed method
func (mmDeletePostsFromFeed *mCacheRepoMockDeletePostsFromFeed) Set(f func(ctx context.Context, username string, posts []dto.PostShortInfo) (err error)) *CacheRepoMock {
	if mmDeletePostsFromFeed.defaultExpectation != nil {
		mmDeletePostsFromFeed.mock.t.Fatalf("Default expectation is already set for the cacheRepo.DeletePostsFromFeed method")
	}

	if len(mmDeletePostsFromFeed.expectations) > 0 {
		mmDeletePostsFromFeed.mock.t.Fatalf("Some expectations are already set for the cacheRepo.DeletePostsFromFeed method")
	}

	mmDeletePostsFromFeed.mock.funcDeletePostsFromFeed = f
	return mmDeletePostsFromFeed.mock
}

// When sets expectation for the cacheRepo.DeletePostsFromFeed which will trigger the result defined by the following
// Then helper
func (mmDeletePostsFromFeed *mCacheRepoMockDeletePostsFromFeed) When(ctx context.Context, username string, posts []dto.PostShortInfo) *CacheRepoMockDeletePostsFromFeedExpectation {
	if mmDeletePostsFromFeed.mock.funcDeletePostsFromFeed != nil {
		mmDeletePostsFromFeed.mock.t.Fatalf("CacheRepoMock.DeletePostsFromFeed mock is already set by Set")
	}

	expectation := &CacheRepoMockDeletePostsFromFeedExpectation{
		mock:   mmDeletePostsFromFeed.mock,
		params: &CacheRepoMockDeletePostsFromFeedParams{ctx, username, posts},
	}
	mmDeletePostsFromFeed.expectations = append(mmDeletePostsFromFeed.expectations, expectation)
	return expectation
}

// Then sets up cacheRepo.DeletePostsFromFeed return parameters for the expectation previously defined by the When method
func (e *CacheRepoMockDeletePostsFromFeedExpectation) Then(err error) *CacheRepoMock {
	e.results = &CacheRepoMockDeletePostsFromFeedResults{err}
	return e.mock
}

// DeletePostsFromFeed implements cacheupdater.cacheRepo
func (mmDeletePostsFromFeed *CacheRepoMock) DeletePostsFromFeed(ctx context.Context, username string, posts []dto.PostShortInfo) (err error) {
	mm_atomic.AddUint64(&mmDeletePostsFromFeed.beforeDeletePostsFromFeedCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePostsFromFeed.afterDeletePostsFromFeedCounter, 1)

	if mmDeletePostsFromFeed.inspectFuncDeletePostsFromFeed != nil {
		mmDeletePostsFromFeed.inspectFuncDeletePostsFromFeed(ctx, username, posts)
	}

	mm_params := &CacheRepoMockDeletePostsFromFeedParams{ctx, username, posts}

	// Record call args
	mmDeletePostsFromFeed.DeletePostsFromFeedMock.mutex.Lock()
	mmDeletePostsFromFeed.DeletePostsFromFeedMock.callArgs = append(mmDeletePostsFromFeed.DeletePostsFromFeedMock.callArgs, mm_params)
	mmDeletePostsFromFeed.DeletePostsFromFeedMock.mutex.Unlock()

	for _, e := range mmDeletePostsFromFeed.DeletePostsFromFeedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePostsFromFeed.DeletePostsFromFeedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePostsFromFeed.DeletePostsFromFeedMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePostsFromFeed.DeletePostsFromFeedMock.defaultExpectation.params
		mm_got := CacheRepoMockDeletePostsFromFeedParams{ctx, username, posts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePostsFromFeed.t.Errorf("CacheRepoMock.DeletePostsFromFeed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePostsFromFeed.DeletePostsFromFeedMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePostsFromFeed.t.Fatal("No results are set for the CacheRepoMock.DeletePostsFromFeed")
		}
		return (*mm_results).err
	}
	if mmDeletePostsFromFeed.funcDeletePostsFromFeed != nil {
		return mmDeletePostsFromFeed.funcDeletePostsFromFeed(ctx, username, posts)
	}
	mmDeletePostsFromFeed.t.Fatalf("Unexpected call to CacheRepoMock.DeletePostsFromFeed. %v %v %v", ctx, username, posts)
	return
}

// DeletePostsFromFeedAfterCounter returns a count of finished CacheRepoMock.DeletePostsFromFeed invocations
func (mmDeletePostsFromFeed *CacheRepoMock) DeletePostsFromFeedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePostsFromFeed.afterDeletePostsFromFeedCounter)
}

// DeletePostsFromFeedBeforeCounter returns a count of CacheRepoMock.DeletePostsFromFeed invocations
func (mmDeletePostsFromFeed *CacheRepoMock) DeletePostsFromFeedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePostsFromFeed.beforeDeletePostsFromFeedCounter)
}

// Calls returns a list of arguments used in each call to CacheRepoMock.DeletePostsFromFeed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePostsFromFeed *mCacheRepoMockDeletePostsFromFeed) Calls() []*CacheRepoMockDeletePostsFromFeedParams {
	mmDeletePostsFromFeed.mutex.RLock()

	argCopy := make([]*CacheRepoMockDeletePostsFromFeedParams, len(mmDeletePostsFromFeed.callArgs))
	copy(argCopy, mmDeletePostsFromFeed.callArgs)

	mmDeletePostsFromFeed.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePostsFromFeedDone returns true if the count of the DeletePostsFromFeed invocations corresponds
// the number of defined expectations
func (m *CacheRepoMock) MinimockDeletePostsFromFeedDone() bool {
	for _, e := range m.DeletePostsFromFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePostsFromFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeletePostsFromFeedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePostsFromFeed != nil && mm_atomic.LoadUint64(&m.afterDeletePostsFromFeedCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeletePostsFromFeedInspect logs each unmet expectation
func (m *CacheRepoMock) MinimockDeletePostsFromFeedInspect() {
	for _, e := range m.DeletePostsFromFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheRepoMock.DeletePostsFromFeed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePostsFromFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeletePostsFromFeedCounter) < 1 {
		if m.DeletePostsFromFeedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheRepoMock.DeletePostsFromFeed")
		} else {
			m.t.Errorf("Expected call to CacheRepoMock.DeletePostsFromFeed with params: %#v", *m.DeletePostsFromFeedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePostsFromFeed != nil && mm_atomic.LoadUint64(&m.afterDeletePostsFromFeedCounter) < 1 {
		m.t.Error("Expected call to CacheRepoMock.DeletePostsFromFeed")
	}
}

type mCacheRepoMockGetPostFeed struct {
	mock               *CacheRepoMock
	defaultExpectation *CacheRepoMockGetPostFeedExpectation
	expectations       []*CacheRepoMockGetPostFeedExpectation

	callArgs []*CacheRepoMockGetPostFeedParams
	mutex    sync.RWMutex
}

// CacheRepoMockGetPostFeedExpectation specifies expectation struct of the cacheRepo.GetPostFeed
type CacheRepoMockGetPostFeedExpectation struct {
	mock    *CacheRepoMock
	params  *CacheRepoMockGetPostFeedParams
	results *CacheRepoMockGetPostFeedResults
	Counter uint64
}

// CacheRepoMockGetPostFeedParams contains parameters of the cacheRepo.GetPostFeed
type CacheRepoMockGetPostFeedParams struct {
	ctx      context.Context
	username string
	limit    uint
}

// CacheRepoMockGetPostFeedResults contains results of the cacheRepo.GetPostFeed
type CacheRepoMockGetPostFeedResults struct {
	pa1 []dto.PostShortInfo
	err error
}

// Expect sets up expected params for cacheRepo.GetPostFeed
func (mmGetPostFeed *mCacheRepoMockGetPostFeed) Expect(ctx context.Context, username string, limit uint) *mCacheRepoMockGetPostFeed {
	if mmGetPostFeed.mock.funcGetPostFeed != nil {
		mmGetPostFeed.mock.t.Fatalf("CacheRepoMock.GetPostFeed mock is already set by Set")
	}

	if mmGetPostFeed.defaultExpectation == nil {
		mmGetPostFeed.defaultExpectation = &CacheRepoMockGetPostFeedExpectation{}
	}

	mmGetPostFeed.defaultExpectation.params = &CacheRepoMockGetPostFeedParams{ctx, username, limit}
	for _, e := range mmGetPostFeed.expectations {
		if minimock.Equal(e.params, mmGetPostFeed.defaultExpectation.params) {
			mmGetPostFeed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPostFeed.defaultExpectation.params)
		}
	}

	return mmGetPostFeed
}

// Inspect accepts an inspector function that has same arguments as the cacheRepo.GetPostFeed
func (mmGetPostFeed *mCacheRepoMockGetPostFeed) Inspect(f func(ctx context.Context, username string, limit uint)) *mCacheRepoMockGetPostFeed {
	if mmGetPostFeed.mock.inspectFuncGetPostFeed != nil {
		mmGetPostFeed.mock.t.Fatalf("Inspect function is already set for CacheRepoMock.GetPostFeed")
	}

	mmGetPostFeed.mock.inspectFuncGetPostFeed = f

	return mmGetPostFeed
}

// Return sets up results that will be returned by cacheRepo.GetPostFeed
func (mmGetPostFeed *mCacheRepoMockGetPostFeed) Return(pa1 []dto.PostShortInfo, err error) *CacheRepoMock {
	if mmGetPostFeed.mock.funcGetPostFeed != nil {
		mmGetPostFeed.mock.t.Fatalf("CacheRepoMock.GetPostFeed mock is already set by Set")
	}

	if mmGetPostFeed.defaultExpectation == nil {
		mmGetPostFeed.defaultExpectation = &CacheRepoMockGetPostFeedExpectation{mock: mmGetPostFeed.mock}
	}
	mmGetPostFeed.defaultExpectation.results = &CacheRepoMockGetPostFeedResults{pa1, err}
	return mmGetPostFeed.mock
}

//Set uses given function f to mock the cacheRepo.GetPostFeed method
func (mmGetPostFeed *mCacheRepoMockGetPostFeed) Set(f func(ctx context.Context, username string, limit uint) (pa1 []dto.PostShortInfo, err error)) *CacheRepoMock {
	if mmGetPostFeed.defaultExpectation != nil {
		mmGetPostFeed.mock.t.Fatalf("Default expectation is already set for the cacheRepo.GetPostFeed method")
	}

	if len(mmGetPostFeed.expectations) > 0 {
		mmGetPostFeed.mock.t.Fatalf("Some expectations are already set for the cacheRepo.GetPostFeed method")
	}

	mmGetPostFeed.mock.funcGetPostFeed = f
	return mmGetPostFeed.mock
}

// When sets expectation for the cacheRepo.GetPostFeed which will trigger the result defined by the following
// Then helper
func (mmGetPostFeed *mCacheRepoMockGetPostFeed) When(ctx context.Context, username string, limit uint) *CacheRepoMockGetPostFeedExpectation {
	if mmGetPostFeed.mock.funcGetPostFeed != nil {
		mmGetPostFeed.mock.t.Fatalf("CacheRepoMock.GetPostFeed mock is already set by Set")
	}

	expectation := &CacheRepoMockGetPostFeedExpectation{
		mock:   mmGetPostFeed.mock,
		params: &CacheRepoMockGetPostFeedParams{ctx, username, limit},
	}
	mmGetPostFeed.expectations = append(mmGetPostFeed.expectations, expectation)
	return expectation
}

// Then sets up cacheRepo.GetPostFeed return parameters for the expectation previously defined by the When method
func (e *CacheRepoMockGetPostFeedExpectation) Then(pa1 []dto.PostShortInfo, err error) *CacheRepoMock {
	e.results = &CacheRepoMockGetPostFeedResults{pa1, err}
	return e.mock
}

// GetPostFeed implements cacheupdater.cacheRepo
func (mmGetPostFeed *CacheRepoMock) GetPostFeed(ctx context.Context, username string, limit uint) (pa1 []dto.PostShortInfo, err error) {
	mm_atomic.AddUint64(&mmGetPostFeed.beforeGetPostFeedCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPostFeed.afterGetPostFeedCounter, 1)

	if mmGetPostFeed.inspectFuncGetPostFeed != nil {
		mmGetPostFeed.inspectFuncGetPostFeed(ctx, username, limit)
	}

	mm_params := &CacheRepoMockGetPostFeedParams{ctx, username, limit}

	// Record call args
	mmGetPostFeed.GetPostFeedMock.mutex.Lock()
	mmGetPostFeed.GetPostFeedMock.callArgs = append(mmGetPostFeed.GetPostFeedMock.callArgs, mm_params)
	mmGetPostFeed.GetPostFeedMock.mutex.Unlock()

	for _, e := range mmGetPostFeed.GetPostFeedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetPostFeed.GetPostFeedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPostFeed.GetPostFeedMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPostFeed.GetPostFeedMock.defaultExpectation.params
		mm_got := CacheRepoMockGetPostFeedParams{ctx, username, limit}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPostFeed.t.Errorf("CacheRepoMock.GetPostFeed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPostFeed.GetPostFeedMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPostFeed.t.Fatal("No results are set for the CacheRepoMock.GetPostFeed")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetPostFeed.funcGetPostFeed != nil {
		return mmGetPostFeed.funcGetPostFeed(ctx, username, limit)
	}
	mmGetPostFeed.t.Fatalf("Unexpected call to CacheRepoMock.GetPostFeed. %v %v %v", ctx, username, limit)
	return
}

// GetPostFeedAfterCounter returns a count of finished CacheRepoMock.GetPostFeed invocations
func (mmGetPostFeed *CacheRepoMock) GetPostFeedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostFeed.afterGetPostFeedCounter)
}

// GetPostFeedBeforeCounter returns a count of CacheRepoMock.GetPostFeed invocations
func (mmGetPostFeed *CacheRepoMock) GetPostFeedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostFeed.beforeGetPostFeedCounter)
}

// Calls returns a list of arguments used in each call to CacheRepoMock.GetPostFeed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPostFeed *mCacheRepoMockGetPostFeed) Calls() []*CacheRepoMockGetPostFeedParams {
	mmGetPostFeed.mutex.RLock()

	argCopy := make([]*CacheRepoMockGetPostFeedParams, len(mmGetPostFeed.callArgs))
	copy(argCopy, mmGetPostFeed.callArgs)

	mmGetPostFeed.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostFeedDone returns true if the count of the GetPostFeed invocations corresponds
// the number of defined expectations
func (m *CacheRepoMock) MinimockGetPostFeedDone() bool {
	for _, e := range m.GetPostFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPostFeedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPostFeed != nil && mm_atomic.LoadUint64(&m.afterGetPostFeedCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPostFeedInspect logs each unmet expectation
func (m *CacheRepoMock) MinimockGetPostFeedInspect() {
	for _, e := range m.GetPostFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheRepoMock.GetPostFeed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPostFeedCounter) < 1 {
		if m.GetPostFeedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheRepoMock.GetPostFeed")
		} else {
			m.t.Errorf("Expected call to CacheRepoMock.GetPostFeed with params: %#v", *m.GetPostFeedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPostFeed != nil && mm_atomic.LoadUint64(&m.afterGetPostFeedCounter) < 1 {
		m.t.Error("Expected call to CacheRepoMock.GetPostFeed")
	}
}

type mCacheRepoMockPushPostToFeed struct {
	mock               *CacheRepoMock
	defaultExpectation *CacheRepoMockPushPostToFeedExpectation
	expectations       []*CacheRepoMockPushPostToFeedExpectation

	callArgs []*CacheRepoMockPushPostToFeedParams
	mutex    sync.RWMutex
}

// CacheRepoMockPushPostToFeedExpectation specifies expectation struct of the cacheRepo.PushPostToFeed
type CacheRepoMockPushPostToFeedExpectation struct {
	mock    *CacheRepoMock
	params  *CacheRepoMockPushPostToFeedParams
	results *CacheRepoMockPushPostToFeedResults
	Counter uint64
}

// CacheRepoMockPushPostToFeedParams contains parameters of the cacheRepo.PushPostToFeed
type CacheRepoMockPushPostToFeedParams struct {
	ctx       context.Context
	post      entity.Post
	usernames []string
	feedLimit uint
}

// CacheRepoMockPushPostToFeedResults contains results of the cacheRepo.PushPostToFeed
type CacheRepoMockPushPostToFeedResults struct {
	err error
}

// Expect sets up expected params for cacheRepo.PushPostToFeed
func (mmPushPostToFeed *mCacheRepoMockPushPostToFeed) Expect(ctx context.Context, post entity.Post, usernames []string, feedLimit uint) *mCacheRepoMockPushPostToFeed {
	if mmPushPostToFeed.mock.funcPushPostToFeed != nil {
		mmPushPostToFeed.mock.t.Fatalf("CacheRepoMock.PushPostToFeed mock is already set by Set")
	}

	if mmPushPostToFeed.defaultExpectation == nil {
		mmPushPostToFeed.defaultExpectation = &CacheRepoMockPushPostToFeedExpectation{}
	}

	mmPushPostToFeed.defaultExpectation.params = &CacheRepoMockPushPostToFeedParams{ctx, post, usernames, feedLimit}
	for _, e := range mmPushPostToFeed.expectations {
		if minimock.Equal(e.params, mmPushPostToFeed.defaultExpectation.params) {
			mmPushPostToFeed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPushPostToFeed.defaultExpectation.params)
		}
	}

	return mmPushPostToFeed
}

// Inspect accepts an inspector function that has same arguments as the cacheRepo.PushPostToFeed
func (mmPushPostToFeed *mCacheRepoMockPushPostToFeed) Inspect(f func(ctx context.Context, post entity.Post, usernames []string, feedLimit uint)) *mCacheRepoMockPushPostToFeed {
	if mmPushPostToFeed.mock.inspectFuncPushPostToFeed != nil {
		mmPushPostToFeed.mock.t.Fatalf("Inspect function is already set for CacheRepoMock.PushPostToFeed")
	}

	mmPushPostToFeed.mock.inspectFuncPushPostToFeed = f

	return mmPushPostToFeed
}

// Return sets up results that will be returned by cacheRepo.PushPostToFeed
func (mmPushPostToFeed *mCacheRepoMockPushPostToFeed) Return(err error) *CacheRepoMock {
	if mmPushPostToFeed.mock.funcPushPostToFeed != nil {
		mmPushPostToFeed.mock.t.Fatalf("CacheRepoMock.PushPostToFeed mock is already set by Set")
	}

	if mmPushPostToFeed.defaultExpectation == nil {
		mmPushPostToFeed.defaultExpectation = &CacheRepoMockPushPostToFeedExpectation{mock: mmPushPostToFeed.mock}
	}
	mmPushPostToFeed.defaultExpectation.results = &CacheRepoMockPushPostToFeedResults{err}
	return mmPushPostToFeed.mock
}

//Set uses given function f to mock the cacheRepo.PushPostToFeed method
func (mmPushPostToFeed *mCacheRepoMockPushPostToFeed) Set(f func(ctx context.Context, post entity.Post, usernames []string, feedLimit uint) (err error)) *CacheRepoMock {
	if mmPushPostToFeed.defaultExpectation != nil {
		mmPushPostToFeed.mock.t.Fatalf("Default expectation is already set for the cacheRepo.PushPostToFeed method")
	}

	if len(mmPushPostToFeed.expectations) > 0 {
		mmPushPostToFeed.mock.t.Fatalf("Some expectations are already set for the cacheRepo.PushPostToFeed method")
	}

	mmPushPostToFeed.mock.funcPushPostToFeed = f
	return mmPushPostToFeed.mock
}

// When sets expectation for the cacheRepo.PushPostToFeed which will trigger the result defined by the following
// Then helper
func (mmPushPostToFeed *mCacheRepoMockPushPostToFeed) When(ctx context.Context, post entity.Post, usernames []string, feedLimit uint) *CacheRepoMockPushPostToFeedExpectation {
	if mmPushPostToFeed.mock.funcPushPostToFeed != nil {
		mmPushPostToFeed.mock.t.Fatalf("CacheRepoMock.PushPostToFeed mock is already set by Set")
	}

	expectation := &CacheRepoMockPushPostToFeedExpectation{
		mock:   mmPushPostToFeed.mock,
		params: &CacheRepoMockPushPostToFeedParams{ctx, post, usernames, feedLimit},
	}
	mmPushPostToFeed.expectations = append(mmPushPostToFeed.expectations, expectation)
	return expectation
}

// Then sets up cacheRepo.PushPostToFeed return parameters for the expectation previously defined by the When method
func (e *CacheRepoMockPushPostToFeedExpectation) Then(err error) *CacheRepoMock {
	e.results = &CacheRepoMockPushPostToFeedResults{err}
	return e.mock
}

// PushPostToFeed implements cacheupdater.cacheRepo
func (mmPushPostToFeed *CacheRepoMock) PushPostToFeed(ctx context.Context, post entity.Post, usernames []string, feedLimit uint) (err error) {
	mm_atomic.AddUint64(&mmPushPostToFeed.beforePushPostToFeedCounter, 1)
	defer mm_atomic.AddUint64(&mmPushPostToFeed.afterPushPostToFeedCounter, 1)

	if mmPushPostToFeed.inspectFuncPushPostToFeed != nil {
		mmPushPostToFeed.inspectFuncPushPostToFeed(ctx, post, usernames, feedLimit)
	}

	mm_params := &CacheRepoMockPushPostToFeedParams{ctx, post, usernames, feedLimit}

	// Record call args
	mmPushPostToFeed.PushPostToFeedMock.mutex.Lock()
	mmPushPostToFeed.PushPostToFeedMock.callArgs = append(mmPushPostToFeed.PushPostToFeedMock.callArgs, mm_params)
	mmPushPostToFeed.PushPostToFeedMock.mutex.Unlock()

	for _, e := range mmPushPostToFeed.PushPostToFeedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPushPostToFeed.PushPostToFeedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPushPostToFeed.PushPostToFeedMock.defaultExpectation.Counter, 1)
		mm_want := mmPushPostToFeed.PushPostToFeedMock.defaultExpectation.params
		mm_got := CacheRepoMockPushPostToFeedParams{ctx, post, usernames, feedLimit}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPushPostToFeed.t.Errorf("CacheRepoMock.PushPostToFeed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPushPostToFeed.PushPostToFeedMock.defaultExpectation.results
		if mm_results == nil {
			mmPushPostToFeed.t.Fatal("No results are set for the CacheRepoMock.PushPostToFeed")
		}
		return (*mm_results).err
	}
	if mmPushPostToFeed.funcPushPostToFeed != nil {
		return mmPushPostToFeed.funcPushPostToFeed(ctx, post, usernames, feedLimit)
	}
	mmPushPostToFeed.t.Fatalf("Unexpected call to CacheRepoMock.PushPostToFeed. %v %v %v %v", ctx, post, usernames, feedLimit)
	return
}

// PushPostToFeedAfterCounter returns a count of finished CacheRepoMock.PushPostToFeed invocations
func (mmPushPostToFeed *CacheRepoMock) PushPostToFeedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPushPostToFeed.afterPushPostToFeedCounter)
}

// PushPostToFeedBeforeCounter returns a count of CacheRepoMock.PushPostToFeed invocations
func (mmPushPostToFeed *CacheRepoMock) PushPostToFeedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPushPostToFeed.beforePushPostToFeedCounter)
}

// Calls returns a list of arguments used in each call to CacheRepoMock.PushPostToFeed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPushPostToFeed *mCacheRepoMockPushPostToFeed) Calls() []*CacheRepoMockPushPostToFeedParams {
	mmPushPostToFeed.mutex.RLock()

	argCopy := make([]*CacheRepoMockPushPostToFeedParams, len(mmPushPostToFeed.callArgs))
	copy(argCopy, mmPushPostToFeed.callArgs)

	mmPushPostToFeed.mutex.RUnlock()

	return argCopy
}

// MinimockPushPostToFeedDone returns true if the count of the PushPostToFeed invocations corresponds
// the number of defined expectations
func (m *CacheRepoMock) MinimockPushPostToFeedDone() bool {
	for _, e := range m.PushPostToFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PushPostToFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPushPostToFeedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPushPostToFeed != nil && mm_atomic.LoadUint64(&m.afterPushPostToFeedCounter) < 1 {
		return false
	}
	return true
}

// MinimockPushPostToFeedInspect logs each unmet expectation
func (m *CacheRepoMock) MinimockPushPostToFeedInspect() {
	for _, e := range m.PushPostToFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheRepoMock.PushPostToFeed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PushPostToFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPushPostToFeedCounter) < 1 {
		if m.PushPostToFeedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheRepoMock.PushPostToFeed")
		} else {
			m.t.Errorf("Expected call to CacheRepoMock.PushPostToFeed with params: %#v", *m.PushPostToFeedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPushPostToFeed != nil && mm_atomic.LoadUint64(&m.afterPushPostToFeedCounter) < 1 {
		m.t.Error("Expected call to CacheRepoMock.PushPostToFeed")
	}
}

type mCacheRepoMockSetCelebrityFriends struct {
	mock               *CacheRepoMock
	defaultExpectation *CacheRepoMockSetCelebrityFriendsExpectation
	expectations       []*CacheRepoMockSetCelebrityFriendsExpectation

	callArgs []*CacheRepoMockSetCelebrityFriendsParams
	mutex    sync.RWMutex
}

// CacheRepoMockSetCelebrityFriendsExpectation specifies expectation struct of the cacheRepo.SetCelebrityFriends
type CacheRepoMockSetCelebrityFriendsExpectation struct {
	mock    *CacheRepoMock
	params  *CacheRepoMockSetCelebrityFriendsParams
	results *CacheRepoMockSetCelebrityFriendsResults
	Counter uint64
}

// CacheRepoMockSetCelebrityFriendsParams contains parameters of the cacheRepo.SetCelebrityFriends
type CacheRepoMockSetCelebrityFriendsParams struct {
	ctx       context.Context
	usercname string
	friends   []string
}

// CacheRepoMockSetCelebrityFriendsResults contains results of the cacheRepo.SetCelebrityFriends
type CacheRepoMockSetCelebrityFriendsResults struct {
	err error
}

// Expect sets up expected params for cacheRepo.SetCelebrityFriends
func (mmSetCelebrityFriends *mCacheRepoMockSetCelebrityFriends) Expect(ctx context.Context, usercname string, friends []string) *mCacheRepoMockSetCelebrityFriends {
	if mmSetCelebrityFriends.mock.funcSetCelebrityFriends != nil {
		mmSetCelebrityFriends.mock.t.Fatalf("CacheRepoMock.SetCelebrityFriends mock is already set by Set")
	}

	if mmSetCelebrityFriends.defaultExpectation == nil {
		mmSetCelebrityFriends.defaultExpectation = &CacheRepoMockSetCelebrityFriendsExpectation{}
	}

	mmSetCelebrityFriends.defaultExpectation.params = &CacheRepoMockSetCelebrityFriendsParams{ctx, usercname, friends}
	for _, e := range mmSetCelebrityFriends.expectations {
		if minimock.Equal(e.params, mmSetCelebrityFriends.defaultExpectation.params) {
			mmSetCelebrityFriends.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetCelebrityFriends.defaultExpectation.params)
		}
	}

	return mmSetCelebrityFriends
}

// Inspect accepts an inspector function that has same arguments as the cacheRepo.SetCelebrityFriends
func (mmSetCelebrityFriends *mCacheRepoMockSetCelebrityFriends) Inspect(f func(ctx context.Context, usercname string, friends []string)) *mCacheRepoMockSetCelebrityFriends {
	if mmSetCelebrityFriends.mock.inspectFuncSetCelebrityFriends != nil {
		mmSetCelebrityFriends.mock.t.Fatalf("Inspect function is already set for CacheRepoMock.SetCelebrityFriends")
	}

	mmSetCelebrityFriends.mock.inspectFuncSetCelebrityFriends = f

	return mmSetCelebrityFriends
}

// Return sets up results that will be returned by cacheRepo.SetCelebrityFriends
func (mmSetCelebrityFriends *mCacheRepoMockSetCelebrityFriends) Return(err error) *CacheRepoMock {
	if mmSetCelebrityFriends.mock.funcSetCelebrityFriends != nil {
		mmSetCelebrityFriends.mock.t.Fatalf("CacheRepoMock.SetCelebrityFriends mock is already set by Set")
	}

	if mmSetCelebrityFriends.defaultExpectation == nil {
		mmSetCelebrityFriends.defaultExpectation = &CacheRepoMockSetCelebrityFriendsExpectation{mock: mmSetCelebrityFriends.mock}
	}
	mmSetCelebrityFriends.defaultExpectation.results = &CacheRepoMockSetCelebrityFriendsResults{err}
	return mmSetCelebrityFriends.mock
}

//Set uses given function f to mock the cacheRepo.SetCelebrityFriends method
func (mmSetCelebrityFriends *mCacheRepoMockSetCelebrityFriends) Set(f func(ctx context.Context, usercname string, friends []string) (err error)) *CacheRepoMock {
	if mmSetCelebrityFriends.defaultExpectation != nil {
		mmSetCelebrityFriends.mock.t.Fatalf("Default expectation is already set for the cacheRepo.SetCelebrityFriends method")
	}

	if len(mmSetCelebrityFriends.expectations) > 0 {
		mmSetCelebrityFriends.mock.t.Fatalf("Some expectations are already set for the cacheRepo.SetCelebrityFriends method")
	}

	mmSetCelebrityFriends.mock.funcSetCelebrityFriends = f
	return mmSetCelebrityFriends.mock
}

// When sets expectation for the cacheRepo.SetCelebrityFriends which will trigger the result defined by the following
// Then helper
func (mmSetCelebrityFriends *mCacheRepoMockSetCelebrityFriends) When(ctx context.Context, usercname string, friends []string) *CacheRepoMockSetCelebrityFriendsExpectation {
	if mmSetCelebrityFriends.mock.funcSetCelebrityFriends != nil {
		mmSetCelebrityFriends.mock.t.Fatalf("CacheRepoMock.SetCelebrityFriends mock is already set by Set")
	}

	expectation := &CacheRepoMockSetCelebrityFriendsExpectation{
		mock:   mmSetCelebrityFriends.mock,
		params: &CacheRepoMockSetCelebrityFriendsParams{ctx, usercname, friends},
	}
	mmSetCelebrityFriends.expectations = append(mmSetCelebrityFriends.expectations, expectation)
	return expectation
}

// Then sets up cacheRepo.SetCelebrityFriends return parameters for the expectation previously defined by the When method
func (e *CacheRepoMockSetCelebrityFriendsExpectation) Then(err error) *CacheRepoMock {
	e.results = &CacheRepoMockSetCelebrityFriendsResults{err}
	return e.mock
}

// SetCelebrityFriends implements cacheupdater.cacheRepo
func (mmSetCelebrityFriends *CacheRepoMock) SetCelebrityFriends(ctx context.Context, usercname string, friends []string) (err error) {
	mm_atomic.AddUint64(&mmSetCelebrityFriends.beforeSetCelebrityFriendsCounter, 1)
	defer mm_atomic.AddUint64(&mmSetCelebrityFriends.afterSetCelebrityFriendsCounter, 1)

	if mmSetCelebrityFriends.inspectFuncSetCelebrityFriends != nil {
		mmSetCelebrityFriends.inspectFuncSetCelebrityFriends(ctx, usercname, friends)
	}

	mm_params := &CacheRepoMockSetCelebrityFriendsParams{ctx, usercname, friends}

	// Record call args
	mmSetCelebrityFriends.SetCelebrityFriendsMock.mutex.Lock()
	mmSetCelebrityFriends.SetCelebrityFriendsMock.callArgs = append(mmSetCelebrityFriends.SetCelebrityFriendsMock.callArgs, mm_params)
	mmSetCelebrityFriends.SetCelebrityFriendsMock.mutex.Unlock()

	for _, e := range mmSetCelebrityFriends.SetCelebrityFriendsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetCelebrityFriends.SetCelebrityFriendsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetCelebrityFriends.SetCelebrityFriendsMock.defaultExpectation.Counter, 1)
		mm_want := mmSetCelebrityFriends.SetCelebrityFriendsMock.defaultExpectation.params
		mm_got := CacheRepoMockSetCelebrityFriendsParams{ctx, usercname, friends}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetCelebrityFriends.t.Errorf("CacheRepoMock.SetCelebrityFriends got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetCelebrityFriends.SetCelebrityFriendsMock.defaultExpectation.results
		if mm_results == nil {
			mmSetCelebrityFriends.t.Fatal("No results are set for the CacheRepoMock.SetCelebrityFriends")
		}
		return (*mm_results).err
	}
	if mmSetCelebrityFriends.funcSetCelebrityFriends != nil {
		return mmSetCelebrityFriends.funcSetCelebrityFriends(ctx, usercname, friends)
	}
	mmSetCelebrityFriends.t.Fatalf("Unexpected call to CacheRepoMock.SetCelebrityFriends. %v %v %v", ctx, usercname, friends)
	return
}

// SetCelebrityFriendsAfterCounter returns a count of finished CacheRepoMock.SetCelebrityFriends invocations
func (mmSetCelebrityFriends *CacheRepoMock) SetCelebrityFriendsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCelebrityFriends.afterSetCelebrityFriendsCounter)
}

// SetCelebrityFriendsBeforeCounter returns a count of CacheRepoMock.SetCelebrityFriends invocations
func (mmSetCelebrityFriends *CacheRepoMock) SetCelebrityFriendsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetCelebrityFriends.beforeSetCelebrityFriendsCounter)
}

// Calls returns a list of arguments used in each call to CacheRepoMock.SetCelebrityFriends.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetCelebrityFriends *mCacheRepoMockSetCelebrityFriends) Calls() []*CacheRepoMockSetCelebrityFriendsParams {
	mmSetCelebrityFriends.mutex.RLock()

	argCopy := make([]*CacheRepoMockSetCelebrityFriendsParams, len(mmSetCelebrityFriends.callArgs))
	copy(argCopy, mmSetCelebrityFriends.callArgs)

	mmSetCelebrityFriends.mutex.RUnlock()

	return argCopy
}

// MinimockSetCelebrityFriendsDone returns true if the count of the SetCelebrityFriends invocations corresponds
// the number of defined expectations
func (m *CacheRepoMock) MinimockSetCelebrityFriendsDone() bool {
	for _, e := range m.SetCelebrityFriendsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetCelebrityFriendsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCelebrityFriendsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetCelebrityFriends != nil && mm_atomic.LoadUint64(&m.afterSetCelebrityFriendsCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetCelebrityFriendsInspect logs each unmet expectation
func (m *CacheRepoMock) MinimockSetCelebrityFriendsInspect() {
	for _, e := range m.SetCelebrityFriendsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheRepoMock.SetCelebrityFriends with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetCelebrityFriendsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetCelebrityFriendsCounter) < 1 {
		if m.SetCelebrityFriendsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheRepoMock.SetCelebrityFriends")
		} else {
			m.t.Errorf("Expected call to CacheRepoMock.SetCelebrityFriends with params: %#v", *m.SetCelebrityFriendsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetCelebrityFriends != nil && mm_atomic.LoadUint64(&m.afterSetCelebrityFriendsCounter) < 1 {
		m.t.Error("Expected call to CacheRepoMock.SetCelebrityFriends")
	}
}

type mCacheRepoMockSetPostFeed struct {
	mock               *CacheRepoMock
	defaultExpectation *CacheRepoMockSetPostFeedExpectation
	expectations       []*CacheRepoMockSetPostFeedExpectation

	callArgs []*CacheRepoMockSetPostFeedParams
	mutex    sync.RWMutex
}

// CacheRepoMockSetPostFeedExpectation specifies expectation struct of the cacheRepo.SetPostFeed
type CacheRepoMockSetPostFeedExpectation struct {
	mock    *CacheRepoMock
	params  *CacheRepoMockSetPostFeedParams
	results *CacheRepoMockSetPostFeedResults
	Counter uint64
}

// CacheRepoMockSetPostFeedParams contains parameters of the cacheRepo.SetPostFeed
type CacheRepoMockSetPostFeedParams struct {
	ctx      context.Context
	username string
	posts    []dto.PostShortInfo
}

// CacheRepoMockSetPostFeedResults contains results of the cacheRepo.SetPostFeed
type CacheRepoMockSetPostFeedResults struct {
	err error
}

// Expect sets up expected params for cacheRepo.SetPostFeed
func (mmSetPostFeed *mCacheRepoMockSetPostFeed) Expect(ctx context.Context, username string, posts []dto.PostShortInfo) *mCacheRepoMockSetPostFeed {
	if mmSetPostFeed.mock.funcSetPostFeed != nil {
		mmSetPostFeed.mock.t.Fatalf("CacheRepoMock.SetPostFeed mock is already set by Set")
	}

	if mmSetPostFeed.defaultExpectation == nil {
		mmSetPostFeed.defaultExpectation = &CacheRepoMockSetPostFeedExpectation{}
	}

	mmSetPostFeed.defaultExpectation.params = &CacheRepoMockSetPostFeedParams{ctx, username, posts}
	for _, e := range mmSetPostFeed.expectations {
		if minimock.Equal(e.params, mmSetPostFeed.defaultExpectation.params) {
			mmSetPostFeed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetPostFeed.defaultExpectation.params)
		}
	}

	return mmSetPostFeed
}

// Inspect accepts an inspector function that has same arguments as the cacheRepo.SetPostFeed
func (mmSetPostFeed *mCacheRepoMockSetPostFeed) Inspect(f func(ctx context.Context, username string, posts []dto.PostShortInfo)) *mCacheRepoMockSetPostFeed {
	if mmSetPostFeed.mock.inspectFuncSetPostFeed != nil {
		mmSetPostFeed.mock.t.Fatalf("Inspect function is already set for CacheRepoMock.SetPostFeed")
	}

	mmSetPostFeed.mock.inspectFuncSetPostFeed = f

	return mmSetPostFeed
}

// Return sets up results that will be returned by cacheRepo.SetPostFeed
func (mmSetPostFeed *mCacheRepoMockSetPostFeed) Return(err error) *CacheRepoMock {
	if mmSetPostFeed.mock.funcSetPostFeed != nil {
		mmSetPostFeed.mock.t.Fatalf("CacheRepoMock.SetPostFeed mock is already set by Set")
	}

	if mmSetPostFeed.defaultExpectation == nil {
		mmSetPostFeed.defaultExpectation = &CacheRepoMockSetPostFeedExpectation{mock: mmSetPostFeed.mock}
	}
	mmSetPostFeed.defaultExpectation.results = &CacheRepoMockSetPostFeedResults{err}
	return mmSetPostFeed.mock
}

//Set uses given function f to mock the cacheRepo.SetPostFeed method
func (mmSetPostFeed *mCacheRepoMockSetPostFeed) Set(f func(ctx context.Context, username string, posts []dto.PostShortInfo) (err error)) *CacheRepoMock {
	if mmSetPostFeed.defaultExpectation != nil {
		mmSetPostFeed.mock.t.Fatalf("Default expectation is already set for the cacheRepo.SetPostFeed method")
	}

	if len(mmSetPostFeed.expectations) > 0 {
		mmSetPostFeed.mock.t.Fatalf("Some expectations are already set for the cacheRepo.SetPostFeed method")
	}

	mmSetPostFeed.mock.funcSetPostFeed = f
	return mmSetPostFeed.mock
}

// When sets expectation for the cacheRepo.SetPostFeed which will trigger the result defined by the following
// Then helper
func (mmSetPostFeed *mCacheRepoMockSetPostFeed) When(ctx context.Context, username string, posts []dto.PostShortInfo) *CacheRepoMockSetPostFeedExpectation {
	if mmSetPostFeed.mock.funcSetPostFeed != nil {
		mmSetPostFeed.mock.t.Fatalf("CacheRepoMock.SetPostFeed mock is already set by Set")
	}

	expectation := &CacheRepoMockSetPostFeedExpectation{
		mock:   mmSetPostFeed.mock,
		params: &CacheRepoMockSetPostFeedParams{ctx, username, posts},
	}
	mmSetPostFeed.expectations = append(mmSetPostFeed.expectations, expectation)
	return expectation
}

// Then sets up cacheRepo.SetPostFeed return parameters for the expectation previously defined by the When method
func (e *CacheRepoMockSetPostFeedExpectation) Then(err error) *CacheRepoMock {
	e.results = &CacheRepoMockSetPostFeedResults{err}
	return e.mock
}

// SetPostFeed implements cacheupdater.cacheRepo
func (mmSetPostFeed *CacheRepoMock) SetPostFeed(ctx context.Context, username string, posts []dto.PostShortInfo) (err error) {
	mm_atomic.AddUint64(&mmSetPostFeed.beforeSetPostFeedCounter, 1)
	defer mm_atomic.AddUint64(&mmSetPostFeed.afterSetPostFeedCounter, 1)

	if mmSetPostFeed.inspectFuncSetPostFeed != nil {
		mmSetPostFeed.inspectFuncSetPostFeed(ctx, username, posts)
	}

	mm_params := &CacheRepoMockSetPostFeedParams{ctx, username, posts}

	// Record call args
	mmSetPostFeed.SetPostFeedMock.mutex.Lock()
	mmSetPostFeed.SetPostFeedMock.callArgs = append(mmSetPostFeed.SetPostFeedMock.callArgs, mm_params)
	mmSetPostFeed.SetPostFeedMock.mutex.Unlock()

	for _, e := range mmSetPostFeed.SetPostFeedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetPostFeed.SetPostFeedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetPostFeed.SetPostFeedMock.defaultExpectation.Counter, 1)
		mm_want := mmSetPostFeed.SetPostFeedMock.defaultExpectation.params
		mm_got := CacheRepoMockSetPostFeedParams{ctx, username, posts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetPostFeed.t.Errorf("CacheRepoMock.SetPostFeed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetPostFeed.SetPostFeedMock.defaultExpectation.results
		if mm_results == nil {
			mmSetPostFeed.t.Fatal("No results are set for the CacheRepoMock.SetPostFeed")
		}
		return (*mm_results).err
	}
	if mmSetPostFeed.funcSetPostFeed != nil {
		return mmSetPostFeed.funcSetPostFeed(ctx, username, posts)
	}
	mmSetPostFeed.t.Fatalf("Unexpected call to CacheRepoMock.SetPostFeed. %v %v %v", ctx, username, posts)
	return
}

// SetPostFeedAfterCounter returns a count of finished CacheRepoMock.SetPostFeed invocations
func (mmSetPostFeed *CacheRepoMock) SetPostFeedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPostFeed.afterSetPostFeedCounter)
}

// SetPostFeedBeforeCounter returns a count of CacheRepoMock.SetPostFeed invocations
func (mmSetPostFeed *CacheRepoMock) SetPostFeedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetPostFeed.beforeSetPostFeedCounter)
}

// Calls returns a list of arguments used in each call to CacheRepoMock.SetPostFeed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetPostFeed *mCacheRepoMockSetPostFeed) Calls() []*CacheRepoMockSetPostFeedParams {
	mmSetPostFeed.mutex.RLock()

	argCopy := make([]*CacheRepoMockSetPostFeedParams, len(mmSetPostFeed.callArgs))
	copy(argCopy, mmSetPostFeed.callArgs)

	mmSetPostFeed.mutex.RUnlock()

	return argCopy
}

// MinimockSetPostFeedDone returns true if the count of the SetPostFeed invocations corresponds
// the number of defined expectations
func (m *CacheRepoMock) MinimockSetPostFeedDone() bool {
	for _, e := range m.SetPostFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPostFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPostFeedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPostFeed != nil && mm_atomic.LoadUint64(&m.afterSetPostFeedCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetPostFeedInspect logs each unmet expectation
func (m *CacheRepoMock) MinimockSetPostFeedInspect() {
	for _, e := range m.SetPostFeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheRepoMock.SetPostFeed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetPostFeedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetPostFeedCounter) < 1 {
		if m.SetPostFeedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheRepoMock.SetPostFeed")
		} else {
			m.t.Errorf("Expected call to CacheRepoMock.SetPostFeed with params: %#v", *m.SetPostFeedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetPostFeed != nil && mm_atomic.LoadUint64(&m.afterSetPostFeedCounter) < 1 {
		m.t.Error("Expected call to CacheRepoMock.SetPostFeed")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CacheRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddCelebrityFriendInspect()

		m.MinimockDeleteCelebrityFriendInspect()

		m.MinimockDeletePostsFromFeedInspect()

		m.MinimockGetPostFeedInspect()

		m.MinimockPushPostToFeedInspect()

		m.MinimockSetCelebrityFriendsInspect()

		m.MinimockSetPostFeedInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CacheRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CacheRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCelebrityFriendDone() &&
		m.MinimockDeleteCelebrityFriendDone() &&
		m.MinimockDeletePostsFromFeedDone() &&
		m.MinimockGetPostFeedDone() &&
		m.MinimockPushPostToFeedDone() &&
		m.MinimockSetCelebrityFriendsDone() &&
		m.MinimockSetPostFeedDone()
}
