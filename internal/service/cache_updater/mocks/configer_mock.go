package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/olgoncharov/otbook/internal/service/cache_updater.configer -o ./internal/service/cache_updater/mocks/configer_mock.go -n ConfigerMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ConfigerMock implements cacheupdater.configer
type ConfigerMock struct {
	t minimock.Tester

	funcPostFeedLimit          func() (i1 int)
	inspectFuncPostFeedLimit   func()
	afterPostFeedLimitCounter  uint64
	beforePostFeedLimitCounter uint64
	PostFeedLimitMock          mConfigerMockPostFeedLimit
}

// NewConfigerMock returns a mock for cacheupdater.configer
func NewConfigerMock(t minimock.Tester) *ConfigerMock {
	m := &ConfigerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.PostFeedLimitMock = mConfigerMockPostFeedLimit{mock: m}

	return m
}

type mConfigerMockPostFeedLimit struct {
	mock               *ConfigerMock
	defaultExpectation *ConfigerMockPostFeedLimitExpectation
	expectations       []*ConfigerMockPostFeedLimitExpectation
}

// ConfigerMockPostFeedLimitExpectation specifies expectation struct of the configer.PostFeedLimit
type ConfigerMockPostFeedLimitExpectation struct {
	mock *ConfigerMock

	results *ConfigerMockPostFeedLimitResults
	Counter uint64
}

// ConfigerMockPostFeedLimitResults contains results of the configer.PostFeedLimit
type ConfigerMockPostFeedLimitResults struct {
	i1 int
}

// Expect sets up expected params for configer.PostFeedLimit
func (mmPostFeedLimit *mConfigerMockPostFeedLimit) Expect() *mConfigerMockPostFeedLimit {
	if mmPostFeedLimit.mock.funcPostFeedLimit != nil {
		mmPostFeedLimit.mock.t.Fatalf("ConfigerMock.PostFeedLimit mock is already set by Set")
	}

	if mmPostFeedLimit.defaultExpectation == nil {
		mmPostFeedLimit.defaultExpectation = &ConfigerMockPostFeedLimitExpectation{}
	}

	return mmPostFeedLimit
}

// Inspect accepts an inspector function that has same arguments as the configer.PostFeedLimit
func (mmPostFeedLimit *mConfigerMockPostFeedLimit) Inspect(f func()) *mConfigerMockPostFeedLimit {
	if mmPostFeedLimit.mock.inspectFuncPostFeedLimit != nil {
		mmPostFeedLimit.mock.t.Fatalf("Inspect function is already set for ConfigerMock.PostFeedLimit")
	}

	mmPostFeedLimit.mock.inspectFuncPostFeedLimit = f

	return mmPostFeedLimit
}

// Return sets up results that will be returned by configer.PostFeedLimit
func (mmPostFeedLimit *mConfigerMockPostFeedLimit) Return(i1 int) *ConfigerMock {
	if mmPostFeedLimit.mock.funcPostFeedLimit != nil {
		mmPostFeedLimit.mock.t.Fatalf("ConfigerMock.PostFeedLimit mock is already set by Set")
	}

	if mmPostFeedLimit.defaultExpectation == nil {
		mmPostFeedLimit.defaultExpectation = &ConfigerMockPostFeedLimitExpectation{mock: mmPostFeedLimit.mock}
	}
	mmPostFeedLimit.defaultExpectation.results = &ConfigerMockPostFeedLimitResults{i1}
	return mmPostFeedLimit.mock
}

//Set uses given function f to mock the configer.PostFeedLimit method
func (mmPostFeedLimit *mConfigerMockPostFeedLimit) Set(f func() (i1 int)) *ConfigerMock {
	if mmPostFeedLimit.defaultExpectation != nil {
		mmPostFeedLimit.mock.t.Fatalf("Default expectation is already set for the configer.PostFeedLimit method")
	}

	if len(mmPostFeedLimit.expectations) > 0 {
		mmPostFeedLimit.mock.t.Fatalf("Some expectations are already set for the configer.PostFeedLimit method")
	}

	mmPostFeedLimit.mock.funcPostFeedLimit = f
	return mmPostFeedLimit.mock
}

// PostFeedLimit implements cacheupdater.configer
func (mmPostFeedLimit *ConfigerMock) PostFeedLimit() (i1 int) {
	mm_atomic.AddUint64(&mmPostFeedLimit.beforePostFeedLimitCounter, 1)
	defer mm_atomic.AddUint64(&mmPostFeedLimit.afterPostFeedLimitCounter, 1)

	if mmPostFeedLimit.inspectFuncPostFeedLimit != nil {
		mmPostFeedLimit.inspectFuncPostFeedLimit()
	}

	if mmPostFeedLimit.PostFeedLimitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPostFeedLimit.PostFeedLimitMock.defaultExpectation.Counter, 1)

		mm_results := mmPostFeedLimit.PostFeedLimitMock.defaultExpectation.results
		if mm_results == nil {
			mmPostFeedLimit.t.Fatal("No results are set for the ConfigerMock.PostFeedLimit")
		}
		return (*mm_results).i1
	}
	if mmPostFeedLimit.funcPostFeedLimit != nil {
		return mmPostFeedLimit.funcPostFeedLimit()
	}
	mmPostFeedLimit.t.Fatalf("Unexpected call to ConfigerMock.PostFeedLimit.")
	return
}

// PostFeedLimitAfterCounter returns a count of finished ConfigerMock.PostFeedLimit invocations
func (mmPostFeedLimit *ConfigerMock) PostFeedLimitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPostFeedLimit.afterPostFeedLimitCounter)
}

// PostFeedLimitBeforeCounter returns a count of ConfigerMock.PostFeedLimit invocations
func (mmPostFeedLimit *ConfigerMock) PostFeedLimitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPostFeedLimit.beforePostFeedLimitCounter)
}

// MinimockPostFeedLimitDone returns true if the count of the PostFeedLimit invocations corresponds
// the number of defined expectations
func (m *ConfigerMock) MinimockPostFeedLimitDone() bool {
	for _, e := range m.PostFeedLimitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PostFeedLimitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPostFeedLimitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPostFeedLimit != nil && mm_atomic.LoadUint64(&m.afterPostFeedLimitCounter) < 1 {
		return false
	}
	return true
}

// MinimockPostFeedLimitInspect logs each unmet expectation
func (m *ConfigerMock) MinimockPostFeedLimitInspect() {
	for _, e := range m.PostFeedLimitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ConfigerMock.PostFeedLimit")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PostFeedLimitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPostFeedLimitCounter) < 1 {
		m.t.Error("Expected call to ConfigerMock.PostFeedLimit")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPostFeedLimit != nil && mm_atomic.LoadUint64(&m.afterPostFeedLimitCounter) < 1 {
		m.t.Error("Expected call to ConfigerMock.PostFeedLimit")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ConfigerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockPostFeedLimitInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ConfigerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ConfigerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockPostFeedLimitDone()
}
